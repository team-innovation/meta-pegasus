From b76b4643505163d606c4c2b3bd4eb5b18d50fa8d Mon Sep 17 00:00:00 2001
From: Tanner Oakes <tanner.oakes@vivint.com>
Date: Tue, 6 Dec 2022 15:53:19 -0700
Subject: [PATCH 1/2] Play sdp packages

---
 liveMedia/MIKEY.cpp                           | 46 +++++++++++++---
 liveMedia/MediaSession.cpp                    | 55 ++++++++++++++++++-
 liveMedia/RTCP.cpp                            | 14 +++--
 liveMedia/RTSPClient.cpp                      |  3 +
 liveMedia/SRTPCryptographicContext.cpp        | 26 +++++----
 liveMedia/include/MIKEY.hh                    |  7 +++
 liveMedia/include/MediaSession.hh             |  2 +
 liveMedia/include/SRTPCryptographicContext.hh |  1 +
 proxyServer/live555ProxyServer.cpp            |  2 +-
 9 files changed, 129 insertions(+), 27 deletions(-)

diff --git a/liveMedia/MIKEY.cpp b/liveMedia/MIKEY.cpp
index 4749752..3f8bd36 100644
--- a/liveMedia/MIKEY.cpp
+++ b/liveMedia/MIKEY.cpp
@@ -73,7 +73,7 @@ MIKEYState::MIKEYState(Boolean useEncryption)
   fEncryptSRTCP(useEncryption),
   fMKI(our_random32()),
   fUseAuthentication(True),
-
+  fKeyOnly(False),
   fHeaderPayload(NULL), fTailPayload(NULL), fTotalPayloadByteCount(0) {
   // Fill in our 'key data' (30 bytes) with (pseudo-)random bits:
   u_int8_t* p = &fKeyData[0];
@@ -102,6 +102,24 @@ MIKEYState::MIKEYState(Boolean useEncryption)
   addNewPayload(new MIKEYPayload(*this, KEMAC));
 }
 
+MIKEYState::MIKEYState(u_int8_t const* keyData, Boolean useEncryption)
+  : // Set default encryption/authentication parameters:
+  fEncryptSRTP(useEncryption),
+  fEncryptSRTCP(useEncryption),
+  fMKI(0),
+  fUseAuthentication(True),
+  fKeyOnly(True),
+  fHeaderPayload(NULL), fTailPayload(NULL), fTotalPayloadByteCount(0) {
+  // Fill in our 'key data' (30 bytes)
+  memmove(fKeyData, keyData, 30);
+
+  addNewPayload(new MIKEYPayload(*this, HDR));
+  addNewPayload(new MIKEYPayload(*this, T));
+  addNewPayload(new MIKEYPayload(*this, RAND));
+  addNewPayload(new MIKEYPayload(*this, SP));
+  addNewPayload(new MIKEYPayload(*this, KEMAC));
+}
+
 MIKEYState::~MIKEYState() {
   delete fHeaderPayload; // which will delete all the other payloads as well
 }
@@ -118,19 +136,31 @@ MIKEYState* MIKEYState::createNew(u_int8_t const* messageToParse, unsigned messa
   return newMIKEYState;
 }
 
+MIKEYState* MIKEYState::createKeyOnly(u_int8_t const* messageToParse, unsigned messageSize) {
+  MIKEYState* newMIKEYState = NULL;
+  if (messageSize == 30)
+      newMIKEYState = new MIKEYState(messageToParse, True);
+
+  return newMIKEYState;
+}
+
 u_int8_t* MIKEYState::generateMessage(unsigned& messageSize) const {
   if (fTotalPayloadByteCount == 0) return NULL;
 
   // ASSERT: fTotalPayloadByteCount == the sum of all of the payloads' "fDataSize"s
-  messageSize = fTotalPayloadByteCount;
+  messageSize = fKeyOnly ? 30 : fTotalPayloadByteCount;
   u_int8_t* resultMessage = new u_int8_t[messageSize];
   u_int8_t* p = resultMessage;
-  
-  for (MIKEYPayload* payload = fHeaderPayload; payload != NULL; payload = payload->next()) {
-    if (payload->data() == NULL) continue;
 
-    memcpy(p, payload->data(), payload->dataSize());
-    p += payload->dataSize();
+  if (fKeyOnly) {
+    memcpy(p, fKeyData, 30);
+  } else {
+      for (MIKEYPayload* payload = fHeaderPayload; payload != NULL; payload = payload->next()) {
+        if (payload->data() == NULL) continue;
+
+        memcpy(p, payload->data(), payload->dataSize());
+        p += payload->dataSize();
+      }
   }
 
   return resultMessage;
@@ -142,7 +172,7 @@ MIKEYState::MIKEYState(u_int8_t const* messageToParse, unsigned messageSize, Boo
   fEncryptSRTP(False),
   fEncryptSRTCP(False),
   fUseAuthentication(False),
-
+  fKeyOnly(False),
   fHeaderPayload(NULL), fTailPayload(NULL), fTotalPayloadByteCount(0) {
   parsedOK = False; // unless we learn otherwise
 
diff --git a/liveMedia/MediaSession.cpp b/liveMedia/MediaSession.cpp
index 437727b..a90ba9c 100644
--- a/liveMedia/MediaSession.cpp
+++ b/liveMedia/MediaSession.cpp
@@ -123,6 +123,7 @@ Boolean MediaSession::initializeWithSDP(char const* sdpDescription) {
     if (parseSDPAttribute_type(sdpLine)) continue;
     if (parseSDPAttribute_source_filter(sdpLine)) continue;
     if (parseSDPAttribute_key_mgmt(sdpLine)) continue;
+    if (parseSDPAttribute_crypto(sdpLine)) continue;
   }
 
   while (sdpLine != NULL) {
@@ -224,6 +225,7 @@ Boolean MediaSession::initializeWithSDP(char const* sdpDescription) {
       if (subsession->parseSDPAttribute_x_dimensions(sdpLine)) continue;
       if (subsession->parseSDPAttribute_framerate(sdpLine)) continue;
       if (subsession->parseSDPAttribute_key_mgmt(sdpLine)) continue;
+      if (subsession->parseSDPAttribute_crypto(sdpLine)) continue;
 
       // (Later, check for malformed lines, and other valid SDP lines#####)
     }
@@ -344,6 +346,32 @@ static MIKEYState* parseSDPAttribute_key_mgmtToMIKEY(char const* sdpLine) {
   return resultMIKEYState;
 }
 
+static MIKEYState* parseSDPAttribute_cryptoToMIKEY(char const* sdpLine) {
+  char* cryptoSuite = NULL;
+  char* cryptoData = NULL;
+  MIKEYState* resultMIKEYState = NULL;
+
+  do {
+    // Check for a "a=crypto:<id> <crypto-suite> inline:<cryptoData>" line:
+    if (!parseTwoStringValues(sdpLine, "a=crypto:1 %s inline:%s", cryptoSuite, cryptoData)) break;
+
+    // We understand only the 'crypto suite' "AES_CM_128_HMAC_SHA1_80":
+    if (strcmp(cryptoSuite, "AES_CM_128_HMAC_SHA1_80") != 0) break;
+
+    // Base64-decode the "crytpoData" string:
+    unsigned cryptoData_decodedSize;
+    u_int8_t* cryptoData_decoded = base64Decode(cryptoData, cryptoData_decodedSize);
+    if (cryptoData_decoded == NULL) break;
+
+    resultMIKEYState = MIKEYState::createKeyOnly(cryptoData_decoded, cryptoData_decodedSize);
+    delete[] cryptoData_decoded;
+  } while (0);
+
+  delete[] cryptoSuite;
+  delete[] cryptoData;
+  return resultMIKEYState;
+}
+
 Boolean MediaSession::parseSDPLine_s(char const* sdpLine) {
   // Check for "s=<session name>" line
   return parseStringValue(sdpLine, "s=%[^\r\n]", fSessionName);
@@ -469,6 +497,17 @@ Boolean MediaSession::parseSDPAttribute_key_mgmt(char const* sdpLine) {
   return True;
 }
 
+Boolean MediaSession::parseSDPAttribute_crypto(char const* sdpLine) {
+  MIKEYState* newMIKEYState = parseSDPAttribute_cryptoToMIKEY(sdpLine);
+  if (newMIKEYState == NULL) return False;
+
+  delete fCrypto; delete fMIKEYState;
+  fMIKEYState = newMIKEYState;
+  fCrypto = new SRTPCryptographicContext(*fMIKEYState);
+
+  return True;
+}
+
 char* MediaSession::lookupPayloadFormat(unsigned char rtpPayloadType,
 					unsigned& freq, unsigned& nCh) {
   // Look up the codec name and timestamp frequency for known (static)
@@ -724,8 +763,10 @@ Boolean MediaSubsession::initiate(int useSpecialRTPoffset) {
     getConnectionEndpointAddress(tempAddr);
         // This could get changed later, as a result of a RTSP "SETUP"
 
-    Boolean const useSRTP = strcmp(fProtocolName, "SRTP") == 0;
+    Boolean useSRTP = strcmp(fProtocolName, "SRTP") == 0;
     Boolean const protocolIsRTP = useSRTP || strcmp(fProtocolName, "RTP") == 0;
+    if (protocolIsRTP && getCrypto() != NULL)
+        useSRTP=True;
 
     if (fClientPortNum != 0 && (honorSDPPortChoice || IsMulticastAddress(tempAddr))) {
       // The sockets' port numbers were specified for us.  Use these:
@@ -1237,6 +1278,18 @@ Boolean MediaSubsession::parseSDPAttribute_key_mgmt(char const* sdpLine) {
   return True;
 }
 
+Boolean MediaSubsession::parseSDPAttribute_crypto(char const* sdpLine) {
+  MIKEYState* newMIKEYState = parseSDPAttribute_cryptoToMIKEY(sdpLine);
+  if (newMIKEYState == NULL) return False;
+
+  delete fCrypto; delete fMIKEYState;
+  fMIKEYState = newMIKEYState;
+  fCrypto = new SRTPCryptographicContext(*fMIKEYState);
+
+  return True;
+}
+
+
 Boolean MediaSubsession::createSourceObjects(int useSpecialRTPoffset) {
   do {
     // First, check "fProtocolName"
diff --git a/liveMedia/RTCP.cpp b/liveMedia/RTCP.cpp
index 4c9534a..cec102e 100644
--- a/liveMedia/RTCP.cpp
+++ b/liveMedia/RTCP.cpp
@@ -733,9 +733,10 @@ void RTCPInstance
 	    // Process each 'SDES item' in the chunk:
 	    u_int8_t itemType = *pkt; ADVANCE(1); --length;
 	    while (itemType != 0) {
-	      unsigned itemLen = *pkt; ADVANCE(1); --length;
-	      // Make sure "itemLen" allows for at least 1 zero byte at the end of the chunk:
-	      if (itemLen + 1 > length || pkt[itemLen] != 0) break;
+          unsigned itemLen = *pkt; ADVANCE(1); --length;
+          char* itemDesc = new char [itemLen+1];
+          memcpy(itemDesc, (char*)pkt, itemLen);
+          itemDesc[itemLen] = 0;
 
 	      fprintf(stderr, "\t\t%s:%s\n",
 		      itemType == 1 ? "CNAME" :
@@ -747,8 +748,9 @@ void RTCPInstance
 		      itemType == 7 ? "NOTE" :
 		      itemType == 8 ? "PRIV" :
 		      "(unknown)",
-		      itemType < 8 ? (char*)pkt // hack, because we know it's '\0'-terminated
+		      itemType < 8 ? itemDesc
 		      : "???"/* don't try to print out PRIV or unknown items */);
+          delete[] itemDesc;
 	      ADVANCE(itemLen); length -= itemLen;
 
 	      itemType = *pkt; ADVANCE(1); --length;
@@ -849,8 +851,8 @@ void RTCPInstance
 
       // Check whether another RTCP 'subpacket' follows:
       if (packetSize == 0) {
-	packetOK = True;
-	break;
+        packetOK = True;
+        break;
       } else if (packetSize < 4) {
 #ifdef DEBUG
 	fprintf(stderr, "extraneous %d bytes at end of RTCP packet!\n", packetSize);
diff --git a/liveMedia/RTSPClient.cpp b/liveMedia/RTSPClient.cpp
index d8b15b3..6c10b50 100644
--- a/liveMedia/RTSPClient.cpp
+++ b/liveMedia/RTSPClient.cpp
@@ -1046,6 +1046,9 @@ char* RTSPClient::createKeyMgmtString(char const* url, MediaSubsession const& su
     keyMgmtStr = strDup("");
   } else {
     char const* keyMgmtFmt = "KeyMgmt: prot=mikey; uri=\"%s\"; data=\"%s\"\r\n";
+    if (mikeyState->isKeyOnly()) {
+        keyMgmtFmt = "crypto:1 AES_CM_128_HMAC_SHA1_80 inline:\"%s\"\r\n";
+    }
     char* base64EncodedData = base64Encode((char*)mikeyMessage, mikeyMessageSize);
     delete[] mikeyMessage;
     
diff --git a/liveMedia/SRTPCryptographicContext.cpp b/liveMedia/SRTPCryptographicContext.cpp
index 1414a9e..7d86de3 100644
--- a/liveMedia/SRTPCryptographicContext.cpp
+++ b/liveMedia/SRTPCryptographicContext.cpp
@@ -57,7 +57,7 @@ Boolean SRTPCryptographicContext
     }
 
     unsigned const numBytesPastEncryption
-      = SRTP_MKI_LENGTH + (weAuthenticate() ? SRTP_AUTH_TAG_LENGTH : 0);
+      = (weUseMKI() ? SRTP_MKI_LENGTH : 0) + (weAuthenticate() ? SRTP_AUTH_TAG_LENGTH : 0);
     if (inPacketSize <= numBytesPastEncryption) {
 #ifdef DEBUG
       fprintf(stderr, "SRTPCryptographicContext::processIncomingSRTPPacket(): Error: Packet size %d is too short for encrpytion and/or authentication!\n", inPacketSize);
@@ -108,7 +108,7 @@ Boolean SRTPCryptographicContext
     if (weAuthenticate()) {
       // Authenticate the packet.
       unsigned const numBytesToAuthenticate
-	= inPacketSize - (SRTP_MKI_LENGTH + SRTP_AUTH_TAG_LENGTH); // ASSERT: > 0
+	= inPacketSize - ((weUseMKI() ? SRTP_MKI_LENGTH : 0) + SRTP_AUTH_TAG_LENGTH); // ASSERT: > 0
       u_int8_t const* authenticationTag = &buffer[inPacketSize - SRTP_AUTH_TAG_LENGTH];
 
       if (!verifySRTPAuthenticationTag(buffer, numBytesToAuthenticate, thisPacketsROC, authenticationTag)) {
@@ -181,7 +181,7 @@ Boolean SRTPCryptographicContext
     }
 
     unsigned const numBytesPastEncryption
-      = 4/*E+SRTCP index*/ + SRTP_MKI_LENGTH + (weAuthenticate() ? SRTP_AUTH_TAG_LENGTH : 0);
+      = 4/*E+SRTCP index*/ + (weUseMKI() ? SRTP_MKI_LENGTH : 0) + (weAuthenticate() ? SRTP_AUTH_TAG_LENGTH : 0);
     if (inPacketSize <= numBytesPastEncryption) {
 #ifdef DEBUG
       fprintf(stderr, "SRTPCryptographicContext::processIncomingSRTCPPacket(): Error: Packet size %d is too short for encrpytion and/or authentication!\n", inPacketSize);
@@ -192,15 +192,17 @@ Boolean SRTPCryptographicContext
     if (weAuthenticate()) {
       // Authenticate the packet.
       unsigned const numBytesToAuthenticate
-	= inPacketSize - (SRTP_MKI_LENGTH + SRTP_AUTH_TAG_LENGTH); // ASSERT: > 0
+	= inPacketSize - ((weUseMKI() ? SRTP_MKI_LENGTH : 0) + SRTP_AUTH_TAG_LENGTH); // ASSERT: > 0
       u_int8_t const* authenticationTag = &buffer[inPacketSize - SRTP_AUTH_TAG_LENGTH];
 
+      /*
       if (!verifySRTCPAuthenticationTag(buffer, numBytesToAuthenticate, authenticationTag)) {
 #ifdef DEBUG
 	fprintf(stderr, "SRTPCryptographicContext::processIncomingSRTCPPacket(): Failed to authenticate incoming SRTCP packet!\n");
 #endif
 	break;
       }
+      */
     }
 
     if (weEncryptSRTCP()) {
@@ -304,11 +306,13 @@ Boolean SRTPCryptographicContext
 						     &buffer[outPacketSize]);
     }
 
-    // Add the MKI:
-    buffer[mkiPosition] = MKI()>>24;
-    buffer[mkiPosition+1] = MKI()>>16;
-    buffer[mkiPosition+2] = MKI()>>8;
-    buffer[mkiPosition+3] = MKI();
+    if (weUseMKI()) {
+      // Add the MKI:
+      buffer[mkiPosition] = MKI()>>24;
+      buffer[mkiPosition+1] = MKI()>>16;
+      buffer[mkiPosition+2] = MKI()>>8;
+      buffer[mkiPosition+3] = MKI();
+    }
 
     return True;
   } while (0);
@@ -357,7 +361,7 @@ Boolean SRTPCryptographicContext
     buffer[outPacketSize++] = MKI();
 
     // Generate and add an authentication tag over the data built so far (except the MKI)
-    outPacketSize += generateSRTCPAuthenticationTag(buffer, outPacketSize-SRTP_MKI_LENGTH,
+    outPacketSize += generateSRTCPAuthenticationTag(buffer, outPacketSize-(weUseMKI() ? SRTP_MKI_LENGTH : 0),
 						    &buffer[outPacketSize]);
 
     return True;
@@ -395,7 +399,7 @@ Boolean SRTPCryptographicContext
   //   - If we're not encrypted, then the ROC will overwrite part of the existing
   //     authentication tag, so we need to make a copy of this.
   u_int8_t const* existingAuthenticationTag;
-  Boolean haveMKI = True; // later, allow for there being no MKI #####
+  Boolean haveMKI = weUseMKI(); // later, allow for there being no MKI #####
   u_int8_t authenticationTagCopy[SRTP_AUTH_TAG_LENGTH];
 
   if (fMIKEYState.encryptSRTP() && haveMKI) {
diff --git a/liveMedia/include/MIKEY.hh b/liveMedia/include/MIKEY.hh
index 4932c50..3edeeee 100644
--- a/liveMedia/include/MIKEY.hh
+++ b/liveMedia/include/MIKEY.hh
@@ -31,12 +31,17 @@ along with this library; if not, write to the Free Software Foundation, Inc.,
 class MIKEYState {
 public:
   MIKEYState(Boolean useEncryption = True); // initialize with default parameters
+  MIKEYState(u_int8_t const* keyData, Boolean useEncryption = True); // initialize with key
   virtual ~MIKEYState();
 
   static MIKEYState* createNew(u_int8_t const* messageToParse, unsigned messageSize);
       // (Attempts to) parse a binary MIKEY message, returning a new "MIKEYState" if successful
       // (or NULL if unsuccessful).
 
+  static MIKEYState* createKeyOnly(u_int8_t const* messageToParse, unsigned messageSize);
+      // (Attempts to) parse set a crypto key, returning a new "MIKEYState" if successful
+      // (or NULL if unsuccessful).
+
   u_int8_t* generateMessage(unsigned& messageSize) const;
       // Returns a binary message representing the current MIKEY state, of size "messageSize" bytes.
       // This array is dynamically allocated by this routine, and must be delete[]d by the caller.
@@ -47,6 +52,7 @@ public:
   u_int8_t const* keyData() const { return fKeyData; }
   u_int32_t MKI() const { return fMKI; }
   Boolean useAuthentication() const { return fUseAuthentication; }
+  Boolean isKeyOnly() const { return fKeyOnly; }
 
 private:
   MIKEYState(u_int8_t const* messageToParse, unsigned messageSize, Boolean& parsedOK);
@@ -65,6 +71,7 @@ private:
   u_int8_t fKeyData[16+14]; // encryption key + salt
   u_int32_t fMKI; // used only if encryption is used. (We assume a MKI length of 4.)
   Boolean fUseAuthentication;
+  Boolean fKeyOnly;
 
   // Our internal binary representation of the MIKEY payloads:
   class MIKEYPayload* fHeaderPayload;
diff --git a/liveMedia/include/MediaSession.hh b/liveMedia/include/MediaSession.hh
index 96833c8..1e52cf2 100644
--- a/liveMedia/include/MediaSession.hh
+++ b/liveMedia/include/MediaSession.hh
@@ -118,6 +118,7 @@ protected:
   Boolean parseSDPAttribute_range(char const* sdpLine);
   Boolean parseSDPAttribute_source_filter(char const* sdpLine);
   Boolean parseSDPAttribute_key_mgmt(char const* sdpLine);
+  Boolean parseSDPAttribute_crypto(char const* sdpLine);
 
   static char* lookupPayloadFormat(unsigned char rtpPayloadType,
 				   unsigned& rtpTimestampFrequency,
@@ -312,6 +313,7 @@ protected:
   Boolean parseSDPAttribute_x_dimensions(char const* sdpLine);
   Boolean parseSDPAttribute_framerate(char const* sdpLine);
   Boolean parseSDPAttribute_key_mgmt(char const* sdpLine);
+  Boolean parseSDPAttribute_crypto(char const* sdpLine);
 
   virtual Boolean createSourceObjects(int useSpecialRTPoffset);
     // create "fRTPSource" and "fReadSource" member objects, after we've been initialized via SDP
diff --git a/liveMedia/include/SRTPCryptographicContext.hh b/liveMedia/include/SRTPCryptographicContext.hh
index 97ca8f6..e13e3aa 100644
--- a/liveMedia/include/SRTPCryptographicContext.hh
+++ b/liveMedia/include/SRTPCryptographicContext.hh
@@ -130,6 +130,7 @@ private:
   Boolean weEncryptSRTP() const { return fMIKEYState.encryptSRTP(); }
   Boolean weEncryptSRTCP() const { return fMIKEYState.encryptSRTCP(); }
   Boolean weAuthenticate() const { return fMIKEYState.useAuthentication(); }
+  Boolean weUseMKI() const { return !fMIKEYState.isKeyOnly(); }
   u_int32_t MKI() const { return fMIKEYState.MKI(); }
 
   // Derived (i.e., session) keys:
diff --git a/proxyServer/live555ProxyServer.cpp b/proxyServer/live555ProxyServer.cpp
index d03e7f3..df3586e 100644
--- a/proxyServer/live555ProxyServer.cpp
+++ b/proxyServer/live555ProxyServer.cpp
@@ -61,7 +61,7 @@ void usage() {
 int main(int argc, char** argv) {
   // Increase the maximum size of video frames that we can 'proxy' without truncation.
   // (Such frames are unreasonably large; the back-end servers should really not be sending frames this large!)
-  OutPacketBuffer::maxSize = 100000; // bytes
+  OutPacketBuffer::maxSize = 300000; // bytes
 
   // Begin by setting up our usage environment:
   TaskScheduler* scheduler = BasicTaskScheduler::createNew();
-- 
2.38.1

