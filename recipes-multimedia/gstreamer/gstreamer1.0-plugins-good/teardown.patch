diff --git a/gst/rtsp/gstrtspsrc.c b/gst/rtsp/gstrtspsrc.c
index 1f22e980d..3b44ec0f1 100644
--- a/gst/rtsp/gstrtspsrc.c
+++ b/gst/rtsp/gstrtspsrc.c
@@ -232,6 +232,7 @@ gst_rtsp_src_ntp_time_source_get_type (void)
 #define DEFAULT_DO_RETRANSMISSION        TRUE
 #define DEFAULT_NTP_TIME_SOURCE  NTP_TIME_SOURCE_NTP
 #define DEFAULT_USER_AGENT       "GStreamer/" PACKAGE_VERSION
+#define DEFAULT_TEARDOWN_TIMEOUT  (100 * GST_MSECOND)
 
 enum
 {
@@ -269,7 +270,8 @@ enum
   PROP_TLS_INTERACTION,
   PROP_DO_RETRANSMISSION,
   PROP_NTP_TIME_SOURCE,
-  PROP_USER_AGENT
+  PROP_USER_AGENT,
+  PROP_TEARDOWN_TIMEOUT,
 };
 
 #define GST_TYPE_RTSP_NAT_METHOD (gst_rtsp_nat_method_get_type())
@@ -732,6 +734,21 @@ gst_rtspsrc_class_init (GstRTSPSrcClass * klass)
           "The User-Agent string to send to the server",
           DEFAULT_USER_AGENT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
+  /**
+   * GstRtspSrc:teardown-timeout
+   *
+   * When transitioning PAUSED-READY, allow up to timeout (in nanoseconds)
+   * delay in order to send teardown (0 = disabled)
+   *
+   * Since: 1.14
+   */
+  g_object_class_install_property (gobject_class, PROP_TEARDOWN_TIMEOUT,
+      g_param_spec_uint64 ("teardown-timeout", "Teardown Timeout",
+          "When transitioning PAUSED-READY, allow up to timeout (in nanoseconds) "
+          "delay in order to send teardown (0 = disabled)",
+          0, G_MAXUINT64, DEFAULT_TEARDOWN_TIMEOUT,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
   /**
    * GstRTSPSrc::handle-request:
    * @rtspsrc: a #GstRTSPSrc
@@ -879,6 +896,7 @@ gst_rtspsrc_init (GstRTSPSrc * src)
   src->do_retransmission = DEFAULT_DO_RETRANSMISSION;
   src->ntp_time_source = DEFAULT_NTP_TIME_SOURCE;
   src->user_agent = g_strdup (DEFAULT_USER_AGENT);
+  src->teardown_timeout = DEFAULT_TEARDOWN_TIMEOUT;
 
   /* get a list of all extensions */
   src->extensions = gst_rtsp_ext_list_get ();
@@ -896,6 +914,8 @@ gst_rtspsrc_init (GstRTSPSrc * src)
 
   src->state = GST_RTSP_STATE_INVALID;
 
+  g_cond_init (&src->cmd_cond);
+
   GST_OBJECT_FLAG_SET (src, GST_ELEMENT_FLAG_SOURCE);
 }
 
@@ -935,6 +955,8 @@ gst_rtspsrc_finalize (GObject * object)
   g_rec_mutex_clear (&rtspsrc->stream_rec_lock);
   g_rec_mutex_clear (&rtspsrc->state_rec_lock);
 
+  g_cond_clear (&rtspsrc->cmd_cond);
+
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
 
@@ -1161,6 +1183,9 @@ gst_rtspsrc_set_property (GObject * object, guint prop_id, const GValue * value,
       g_free (rtspsrc->user_agent);
       rtspsrc->user_agent = g_value_dup_string (value);
       break;
+    case PROP_TEARDOWN_TIMEOUT:
+      rtspsrc->teardown_timeout = g_value_get_uint64 (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -1304,6 +1329,9 @@ gst_rtspsrc_get_property (GObject * object, guint prop_id, GValue * value,
     case PROP_USER_AGENT:
       g_value_set_string (value, rtspsrc->user_agent);
       break;
+    case PROP_TEARDOWN_TIMEOUT:
+      g_value_set_uint64 (value, rtspsrc->teardown_timeout);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -5405,8 +5433,14 @@ gst_rtspsrc_loop_send_cmd (GstRTSPSrc * src, gint cmd, gint mask)
   if (old == CMD_RECONNECT) {
     GST_DEBUG_OBJECT (src, "ignore, we were reconnecting");
     cmd = CMD_RECONNECT;
-  }
-  if (old != CMD_WAIT) {
+  } else if (old == CMD_CLOSE) {
+    /* our CMD_CLOSE might have interrutped CMD_LOOP. gst_rtspsrc_loop
+     * will send a CMD_WAIT which would cancel our pending CMD_CLOSE (if
+     * still pending). We just avoid it here by making sure CMD_CLOSE is
+     * still the pending command. */
+    GST_DEBUG_OBJECT (src, "ignore, we were closing");
+    cmd = CMD_CLOSE;
+  } else if (old != CMD_WAIT) {
     src->pending_cmd = CMD_WAIT;
     GST_OBJECT_UNLOCK (src);
     /* cancel previous request */
@@ -5432,6 +5466,28 @@ gst_rtspsrc_loop_send_cmd (GstRTSPSrc * src, gint cmd, gint mask)
   return flushed;
 }
 
+static gboolean
+gst_rtspsrc_loop_send_cmd_and_wait (GstRTSPSrc * src, gint cmd, gint mask,
+    GstClockTime timeout)
+{
+  gboolean flushed = gst_rtspsrc_loop_send_cmd (src, cmd, mask);
+
+  if (timeout > 0) {
+    gint64 end_time = g_get_monotonic_time () + (timeout / 1000);
+    GST_OBJECT_LOCK (src);
+    while (src->pending_cmd == cmd || src->busy_cmd == cmd) {
+      if (!g_cond_wait_until (&src->cmd_cond, GST_OBJECT_GET_LOCK (src),
+              end_time)) {
+        GST_WARNING_OBJECT (src,
+            "Timed out waiting for TEARDOWN to be processed.");
+        break;                  /* timeout passed */
+      }
+    }
+    GST_OBJECT_UNLOCK (src);
+  }
+  return flushed;
+}
+
 static gboolean
 gst_rtspsrc_loop (GstRTSPSrc * src)
 {
@@ -7422,6 +7478,7 @@ gst_rtspsrc_close (GstRTSPSrc * src, gboolean async, gboolean only_close)
     /* do TEARDOWN */
     res =
         gst_rtspsrc_init_request (src, &request, GST_RTSP_TEARDOWN, setup_url);
+    GST_LOG_OBJECT (src, "Teardown on %s", setup_url);
     if (res < 0)
       goto create_request_failed;
 
@@ -8142,6 +8199,8 @@ gst_rtspsrc_thread (GstRTSPSrc * src)
   }
 
   GST_OBJECT_LOCK (src);
+  /* No more cmds, wake any waiters */
+  g_cond_broadcast (&src->cmd_cond);
   /* and go back to sleep */
   if (src->pending_cmd == CMD_WAIT) {
     if (src->task)
@@ -8277,7 +8336,8 @@ gst_rtspsrc_change_state (GstElement * element, GstStateChange transition)
       ret = GST_STATE_CHANGE_NO_PREROLL;
       break;
     case GST_STATE_CHANGE_PAUSED_TO_READY:
-      gst_rtspsrc_loop_send_cmd (rtspsrc, CMD_CLOSE, CMD_PAUSE);
+      gst_rtspsrc_loop_send_cmd_and_wait (rtspsrc, CMD_CLOSE, CMD_ALL,
+          rtspsrc->teardown_timeout);
       ret = GST_STATE_CHANGE_SUCCESS;
       break;
     case GST_STATE_CHANGE_READY_TO_NULL:
diff --git a/gst/rtsp/gstrtspsrc.h b/gst/rtsp/gstrtspsrc.h
index a3d0a9a61..ad24ba2df 100644
--- a/gst/rtsp/gstrtspsrc.h
+++ b/gst/rtsp/gstrtspsrc.h
@@ -188,6 +188,7 @@ struct _GstRTSPSrc {
   /* UDP mode loop */
   gint             pending_cmd;
   gint             busy_cmd;
+  GCond            cmd_cond;
   gboolean         ignore_timeout;
   gboolean         open_error;
 
@@ -238,6 +239,7 @@ struct _GstRTSPSrc {
   gboolean          do_retransmission;
   gint              ntp_time_source;
   gchar            *user_agent;
+  GstClockTime      teardown_timeout;
 
   /* state */
   GstRTSPState       state;
