# HG changeset patch
# User Craig Matsuura <cmatsuura@vivint.com>
# Date 1392941587 25200
# Node ID 96cf2fe1509d189cf04efc224788fd8f2e72cfc3
# Parent  41b60e50aab07e7d59a088649744e8cc87c6ab2a
Added Authentication support

diff --git a/client.c b/client.c
--- a/client.c
+++ b/client.c
@@ -170,7 +170,7 @@
  * .zsync _if it is retrieved from a URL_; can be NULL in which case no local
  * copy is made.
  */
-struct zsync_state *read_zsync_control_file(const char *p, const char *fn) {
+struct zsync_state *read_zsync_control_file(const char *p, const char *fn, const char *user) {
     FILE *f;
     struct zsync_state *zs;
     char *lastpath = NULL;
@@ -185,7 +185,7 @@
         }
 
         /* Try URL fetch */
-        f = http_get(p, &lastpath, fn);
+        f = http_get(p, &lastpath, fn, user);
         if (!f) {
             fprintf(stderr, "could not read control file from URL %s\n", p);
             exit(3);
@@ -286,7 +286,7 @@
  * Returns zero if this URL was useful, nonzero if we crashed and burned.
  */
 int fetch_remaining_blocks_http(struct zsync_state *z, const char *url,
-                                int type) {
+                                int type, const char *user) {
     int ret = 0;
     struct range_fetch *rf;
     struct zsync_receiver *zr;
@@ -306,7 +306,7 @@
         free(u);
         return -1;
     }
-    rf = range_fetch_start(u, zr);
+    rf = range_fetch_start(u, zr, user);
     if (!rf) {
         zsync_end_receive(zr);
         free(u);
@@ -365,7 +365,7 @@
  * Using the URLs in the supplied zsync state, downloads data to complete the
  * target file. 
  */
-int fetch_remaining_blocks(struct zsync_state *zs) {
+int fetch_remaining_blocks(struct zsync_state *zs, const char *user) {
     int n, utype;
     const char *const *url = zsync_get_urls(zs, &n, &utype);
     int *status;        /* keep status for each URL - 0 means no error */
@@ -386,7 +386,7 @@
             const char *tryurl = url[try];
 
             /* Try fetching data from this URL */
-            int rc = fetch_remaining_blocks_http(zs, tryurl, utype);
+            int rc = fetch_remaining_blocks_http(zs, tryurl, utype, user);
             if (rc != 0) {
                 fprintf(stderr, "failed to retrieve from %s\n", tryurl);
                 status[try] = 1;
@@ -430,11 +430,12 @@
     long long local_used;
     char *zfname = NULL;
     time_t mtime;
+    char *user = NULL;
 
     srand(getpid());
     {   /* Option parsing */
         int opt;
-        while ((opt = getopt(argc, argv, "A:k:o:i:Vsqvu:C:KT:I:R:S:")) != -1) {
+        while ((opt = getopt(argc, argv, "A:U:k:o:i:Vsqvu:C:KT:I:R:S:")) != -1) {
             switch (opt) {
             case 'A':           /* Authentication options for remote server */
                 {               /* Scan string as hostname=username:password */
@@ -460,6 +461,21 @@
                     }
                 }
                 break;
+            case 'U':           /* username and password login */
+                {               /* -U username:password */
+                    char *p = strdup(optarg);
+                    char *r = p ? strchr(p, ':') : NULL;
+
+                    if (!p || !r) {
+                        fprintf(stderr,
+                                "-U takess username:password\n");
+                        exit(1);
+                    }
+                    else {
+			user = p;
+                    } 
+                }
+                break;
             case 'k':
                 free(zfname);
                 zfname = strdup(optarg);
@@ -556,7 +572,7 @@
     }
 
     /* STEP 1: Read the zsync control file */
-    if ((zs = read_zsync_control_file(argv[optind], zfname)) == NULL)
+    if ((zs = read_zsync_control_file(argv[optind], zfname, user)) == NULL)
         exit(1);
 
     /* Get eventual filename for output, and filename to write to while working */
@@ -640,7 +656,7 @@
     }
 
     /* STEP 3: fetch remaining blocks via the URLs from the .zsync */
-    if (fetch_remaining_blocks(zs) != 0) {
+    if (fetch_remaining_blocks(zs, user) != 0) {
         fprintf(stderr,
                 "failed to retrieve all remaining blocks - no valid download URLs remain. Incomplete transfer left in %s.\n(If this is the download filename with .part appended, zsync will automatically pick this up and reuse the data it has already done if you retry in this dir.)\n",
                 temp_file);
diff --git a/http.c b/http.c
--- a/http.c
+++ b/http.c
@@ -89,7 +89,7 @@
 }
 
 /* Get a curl easy handle based on our global options. Returns NULL on failure */
-CURL *make_curl_handle() {
+CURL *make_curl_handle(const char *user) {
     CURL *curl;
     CURLcode res;
 
@@ -175,6 +175,12 @@
         curl_easy_setopt( curl, CURLOPT_TIMEOUT, use_timeout );
     }
 
+    if (user) {
+   	//curl_easy_setopt(curl, CURLOPT_HTTPAUTH, CURLAUTH_BASIC|CURLAUTH_DIGEST);
+   	curl_easy_setopt(curl, CURLOPT_HTTPAUTH, CURLAUTH_DIGEST);
+	curl_easy_setopt(curl, CURLOPT_USERPWD, user);
+    }
+
     return curl;
 }
 
@@ -211,7 +217,7 @@
  *      If-Unmodified-Since, and Range to resume transfers on the .part file
  * XXX: Non-curl version had a progress meter
  */
-FILE *http_get(const char *orig_url, char **track_referer, const char *tfname) {
+FILE *http_get(const char *orig_url, char **track_referer, const char *tfname, const char *user) {
     FILE *f;
     CURL *curl;
     CURLcode res;
@@ -225,7 +231,7 @@
         return NULL;
     }
 
-    curl = make_curl_handle();
+    curl = make_curl_handle(user);
     if (!curl) {
         /* make_curl_handle already printed an error message */
         fclose(f);
@@ -658,7 +664,7 @@
 /* range_fetch_start(origin_url)
  * Returns a new range fetch object, for the given URL.
  */
-struct range_fetch *range_fetch_start(const char *orig_url, struct zsync_receiver *zr) {
+struct range_fetch *range_fetch_start(const char *orig_url, struct zsync_receiver *zr, const char *user) {
     struct range_fetch *rf;
 
     if (!zr || !orig_url) {
@@ -673,7 +679,7 @@
     rf->zr = zr;
 
     /* Init curl handle */
-    rf->curl = make_curl_handle();
+    rf->curl = make_curl_handle(user);
     if (!rf->curl) {
         /* make_curl_handle already printed an error message */
         free(rf);
diff --git a/http.h b/http.h
--- a/http.h
+++ b/http.h
@@ -27,11 +27,11 @@
 extern int be_verbose;
 extern long use_timeout;
 
-FILE* http_get(const char *orig_url, char **track_referer, const char *tfname);
+FILE* http_get(const char *orig_url, char **track_referer, const char *tfname, const char *user);
 
 struct range_fetch;
 
-struct range_fetch* range_fetch_start(const char* orig_url, struct zsync_receiver* zr);
+struct range_fetch* range_fetch_start(const char* orig_url, struct zsync_receiver* zr, const char *user);
 void range_fetch_addranges(struct range_fetch* rf, off_t* ranges, int nranges);
 int range_fetch_perform(struct range_fetch* rf);
 off_t range_fetch_bytes_down(const struct range_fetch* rf);
