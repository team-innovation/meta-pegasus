#!/bin/bash

# make it easy and flexible to do a quick update

version="-d"
clean=0     # default clean user data directive
quash=0     # default quash image checksum validation directive
debug=0     # default show debugging output directive
dryrun=0    # default dry run directive
aconf=0     # default autoconfirmation directive
switch=0    # default switch partition option
latest=0    # default update to latest build option
downgrade=0 # default downgrading state
installed=0 # default installed state
update_dir="/media/extra/update/"
latest_url="http://updateseng.vivint.com/innovation/updates_digest/develop/" # default web server location of latest build
#latest_url="http://updateseng.vivint.com/innovation/packages/branches/vortex/" # TODO TEST web server location of latest build
inactive_part="/dev/null"
active_version="undefined"
inactive_version="undefined"
update_version="undefined"
errors="" # default comma delimeted usage errors string
wallsly_image=*"sly-qt5-image-imx6dl-slimline"*".tar."*
slimline_image=*"slimline-qt5-image-imx6dl-slimline"*".tar."*
touchlink_image=*"touchlink-qte-image-glibc-ipk"*".tar."*
device="undefined" # default device
product="a Vivint product" # default product
version_file="version"
logfile="/media/extra/update/.update_status"
#logfile="/media/extra/update/.update_status_test" # TODO TEST logfile

# To debug, uncomment the next 2 lines:
#export PS4='+(${BASH_SOURCE}:${LINENO}):'
#set -x

main() {
	
	[ ! -f $logfile ] && touch $logfile && writelogonly "Created log file $logfile"
	writelogonly "START: $(basename $0) version: $(version)"
	id_device
	#device="wallsly" && product="Smart Hub" && version_file="sly-version" # TODO TEST on development host
	#device="slimline" && product="Glance" && version_file="slimline-version" # TODO TEST on development host
	#device="touchlink" && product="SkyControl" && version_file="touchlink-version" # TODO TEST on development host
	parse_args "$@"
}

writelog() {

	echo "$(date) QUICKUPDATE $1" >> $logfile
	echo $1
}

writelogonly() {

	echo "$(date) QUICKUPDATE $1" >> $logfile
}

id_device() {

	# Identify device: Glance, Smart Hub, SkyControl or Other  

	device=$(uname -a |cut -d' ' -f2 |cut -d'-' -f2)
	if [[ $device != "slimline" ]] && [[ $device != "wallsly" ]]; then
		device=$(uname -a |cut -d' ' -f2 |cut -d'-' -f1)
		if [[ $device != "touchlink" ]]; then
			device='other'; fi; fi
	[ $device == "wallsly" ] && product="Smart Hub" && version_file="sly-version"
	[ $device == "slimline" ] && product="Glance" && version_file="slimline-version"
	[ $device == "touchlink" ] && product="SkyControl" && version_file="touchlink-version"
}

print_usage_errors() {

	# parameter 1: usage errors; a comma delimeted string

	if [ -n "$1" ]; then
		errors_list=()
        IFS=',' read -r -a errors_list <<< "$1"
        echo ""
        for (( i = 0 ; i < ${#errors_list[*]} ; i++ )); do
            writelog "Error: ${errors_list[$i]}"; done 
		#[ $debug -eq 0 ] || echo "error array [${errors_list[*]}]"
	fi
}

usage() {

	# parameter 1: usage errors; a comma delimeted string

	if [ -n "$1" ]; then
		print_usage_errors "$1"
	fi

	echo "
Usage:	$(basename $0) [-clsdoyvh] [-f FILE] [-u URL] [-n FILE]

Quickly update or downgrade the software on $product

At least one valid option is required

Options:
	-c	clean configuration data - will reboot $product!!
	-s	manually switch to inactive partition (overrides -f, -u, -l and -n)
	-f FILE	local path to update image (overrides -u, -l and -n)
	-u  URL	web server location of special update (overrides -l and -n)
	-l	get and update to the latest build (overrides -n)
	-n FILE local path to network image
	-v	show device versions
	-h	show help

Directives:
	-d	show debugging output
	-o	omit: clean, switch partition & reboot
	-y	auto confirm all actions

Version: $(version)
	"
	writelogonly "EXIT:  $(basename $0) version: $(version)"
	1>&2; exit 1;
}

show_versions() {

	# Show both the active partition and the inactive partition versions

	[ $debug -eq 0 ] || writelog "device is $device, show_versions in process"
	[ $device == "undefined" ] || [ $device == "other" ] &&
		usage "This device is \"$device\" please run this script on target device,$errors"
	which_inactive
	[ $debug -eq 0 ] || writelog "current partition is $current_part"

	[ -f $current_part/etc/$version_file ] && echo "
== Current Version ==
$(cat $current_part/etc/$version_file)
" || echo "Current version unavailable"

	[ -f $inactive_part/etc/$version_file ] && echo "
== Inactve Version ==
$(cat $inactive_part/etc/$version_file)
" || echo "Inactive version unavailable"

	writelogonly "EXIT:  $(basename $0) version: $(version)"
	1>&2; exit 1;
}

parse_args() {

	opts=":clsdoyvhf:u:n:"

	while getopts $opts opt; do
		case "$opt" in
			c)
				clean=1
				;;
			l)
				latest=1
				;;
			s)
				switch=1
				;;
			f)
				sysimage=$OPTARG
				;;
			u)
				url=$OPTARG
				;;
			n)
				netimage=$OPTARG
				;;
			d)
				debug=1
				;;
			o)
				dryrun=1
				;;
			y)
				aconf=1
				;;
			v)
				writelogonly "Show versions"
				show_versions
				;;
			h)
				writelogonly "Show help"
				usage
				;;
		esac
	done

	[ $debug -eq 0 ] || writelog "Resetting option index to evaluate options - http://aplawrence.com/Unix/getopts.html"
	
	OPTIND=1
	options=()
	while getopts $opts option; do
		options[${#options[*]}]="$option,$OPTARG"
		[ $debug -eq 0 ] || writelog "$option" $OPTIND $OPTARG
	done
	
	evaluate_options
}

evaluate_options() {

	if [ $debug -ne 0 ]; then
		writelog "clean is: "$clean
		writelog "switch is: "$switch
		writelog "dryrun is: "$dryrun
		writelog "aconf is: "$aconf
		writelog "latest is: "$latest
		writelog "sysimage is: "$sysimage
		writelog "netimage is: "$netimage
		writelog "url is: "$url
	fi

	# make sure the options are valid - use 'options' array
	[ $debug -eq 0 ] || writelog "options array length is: "${#options[*]}
	
	unknown_opts=()
	missing_optargs=()
	for (( i = 0 ; i < ${#options[*]} ; i++ )); do
		element="${options[$i]}"
		opt="${element:0:1}"
		arg="${element:2:1}"

		[ $debug -eq 0 ] || writelog "processing option element: $element"

		case "$opt" in
			"?")
				unknown_opts[${#unknown_opts[*]}]="-$arg option is unknown"
				;;
			":")
				missing_optargs[${#missing_args[*]}]="-$arg argument is missing"
				;;
		esac
	done

	maybe_run_update
}

maybe_run_update() {

	# collect any usage errors; a comma delimeted string
	for (( i = 0 ; i < ${#unknown_opts[*]} ; i++ )); do
		[ -z "$errors" ] && errors="$errors${unknown_opts[$i]}" || errors="$errors,${unknown_opts[$i]}"
		[ $debug -eq 0 ] || writelog "${unknown_opts[$i]}"
	done

	for (( i = 0 ; i < ${#missing_optargs[*]} ; i++ )); do
		[ -z "$errors" ] && errors="$errors${missing_optargs[$i]}" || errors="$errors,${missing_optargs[$i]}"
		[ $debug -eq 0 ] || writelog "${missing_optargs[$i]}"
	done
	
	[ $debug -eq 0 ] || writelog "error string \"$errors\""

	# If there are any usage errors exit early showing the usage errors
	[ -z "$errors" ] || usage "$errors"

	# make sure there is at least on valid option
	[ $clean -gt 0 ] || [ $switch -gt 0 ] || [ $latest -gt 0 ] ||
		[ $sysimage ] || [ $url ] || [ $netimage ] ||
		usage "Please provide at least one valid option,$errors"

	# If there is a valid set of option(s) run the update - overrides are handled here
	[ $switch -gt 0 ] && switch_partition

	[ $sysimage ] && local_sysupdate "$sysimage"

	[ $url ] && url_update "$url"

	[ $latest -gt 0 ] && latest_update

	[ $netimage ] && local_netupdate "$netimage"

	[ $clean -gt 0 ] && clean_user_data

	# If there is no valid set of option(s), show errors with usage instructions
	usage "Unhandled state in maybe_run_update,$errors"
}

stop_procman_and_friends() {
	# Stop the daemons so that we can delete their dbs. Otherwise, when we
	# shutdown, the daemons will recreate them, and we want them to remain
	# gone.
	writelog "Stop procman and the services it starts"
	# This init script uses start-stop-daemon, and doesn't wait for it to
	# exit. It can take over 15-30 seconds for it to stop. So we make sure it
	# is no longer running before proceeding.
	/etc/init.d/procmand stop
	sleep 5
	loop_counter=30
	while : ; do
		pgrep procmand >/dev/null
		if [ $? -eq 0 -a $loop_counter -gt 0 ] ; then
			loop_counter=$((loop_counter - 1))
			sleep 3
		else
			break
		fi
	done
}

clean_user_data() {

	# Remove user configuration data and reboot

	[ $device == "undefined" ] || [ $device == "other" ] &&
		usage "This device is \"$device\" please run this script on target device,$errors"

	[ $debug -eq 0 ] || writelog "clean_user_data"

	prompt "delete all user configuration data on this $product" 

	if [ $dryrun -eq 0 ]; then 
		stop_procman_and_friends

		if [ $device != "slimline" ]; then
			writelog "Zero out ZWave Home ID..."

			# python 3.3 versus 3.5
			[ -f /opt/2gig/zwaved/scripts/set_home_id.pyo ] &&
				python3 /opt/2gig/zwaved/scripts/set_home_id.pyo -hid 00000000 2> /dev/null
			[ -f /opt/2gig/zwaved/scripts/set_home_id.pyc ] &&
				python3 /opt/2gig/zwaved/scripts/set_home_id.pyc -hid 00000000 2> /dev/null

		fi

		writelog "Clearing /media/extra"
		mkdir -p /media/extra/backup
		mkdir -p /media/extra/db
		mkdir -p /media/extra/log
		mkdir -p /media/extra/etc
		mkdir -p /media/extra/conf

		rm -f  /media/extra/* 2> /dev/null
		rm -rf /media/extra/backup/*
		rm -rf /media/extra/db/*
		rm -rf /media/extra/log/*
		rm -rf /media/extra/etc/*

		# preserve the developer mode unlock key if it exists
		[ -d /media/extra/conf/unlock ] && 
			writelog "Preserving developer mode unlock key: $(ls /media/extra/conf/unlock)"
		[ -d /media/extra/conf/unlock ] && cp -a /media/extra/conf/unlock /media/extra
		[ -f /media/extra/conf/ssdp-uuid ] && cp -a /media/extra/conf/ssdp-uuid /media/extra

		rm -rf /media/extra/conf/*

		[ -d /media/extra/unlock ] && mv /media/extra/unlock /media/extra/conf
		[ -f /media/extra/ssdp-uuid ] && mv /media/extra/ssdp-uuid /media/extra/conf

		reboot_device
	else
		writelog "This is a dry run on clean_user_data, nothing changed"
	fi

	writelogonly "EXIT:  $(basename $0) version: $(version)"
	1>&2; exit 0;
}

reboot_device() {

	[ $dryrun -eq 0 ] && writelog "Rebooting"
	[ $dryrun -gt 0 ] && writelog "This is a dry run on reboot_device, not rebooting"
	writelogonly "EXIT:  $(basename $0) version: $(version)"
	sync
	[ $dryrun -eq 0 ] && shutdown -rFt 5 now
    1>&2; exit 0;
}

switch_partition() {

	# Switch to the inactive partition 

	[ $device == "undefined" ] || [ $device == "other" ] &&
		usage "This device is \"$device\" please run this script on target device,$errors"

	writelog "device is $device, switch_partition in process"

	# Validate the inactive partition first!
	which_inactive
	validate_inactive_kernel

	# if this was called early need to check is_downgrade first,
	# otherwise this is unecessary because later callers already checked...
	if [ $switch -gt 0 ]; then
		is_downgrade "switch"
		[ $debug -gt 0 ] && writelog "downgrade is: $downgrade" && writelog "installed is: $installed"
		[ $downgrade -gt 0 ] && prompt "switch partition on $product (downgrade) from $active_version to $inactive_version"
	fi

	writelog "Switching boot partition..."

	if [ $dryrun -eq 0 ]; then 
		bootnum=$(fw_printenv bootnum | cut -d= -f2)

		[ $device == "touchlink" ] || echo 0 > /sys/block/mmcblk0boot1/force_ro

		if [[ $bootnum -eq 1 ]]
		then
			fw_setenv bootnum 2
			writelog "Set bootnum to 2"
		elif [[ $bootnum -eq 2 ]]
		then
			fw_setenv bootnum 1
			writelog "Set bootnum to 1"
		else
			fw_setenv bootnum 2
			writelog "Uh Oh, blindly set bootnum to 2."
		fi
	
	else
		writelog "This is a dry run on switch_partition, nothing changed"
	fi

	[ $clean -eq 0 ] || clean_user_data

	reboot_device
}

is_downgrade() {

	# Check to see if requested operation is a downgrade
	# who checks? : switch_partition, local_sysupdate, url_update, latest_update
	# parameter 1: image name of update - for local, URL and latest type updates 

	[ $debug -eq 0 ] || writelog "is_downgrade running"

	# define $active_version and $inactive_version to be used by compare() function
	set_active_version
	set_inactive_version

	if [ $1 != "undefined" ] && [ $1 != "switch"  ]; then
		[ $debug -eq 0 ] || writelog "comparing update from active to update version"

		# define $update_version to be used by compare() function
		[ $debug -eq 0 ] || writelog "get_version_from_image_name running"
		update_version=$(get_version_from_image_name $1)
		compare $update_version

	elif [ $1 = "undefined" ]; then
		[ $debug -eq 0 ] || writelog "comparing nothing, update image is $1"
		# likely unable to get manifest on latest update - uncommon
		compare $1

	elif [ $1 == "switch" ]; then
		[ $debug -eq 0 ] || writelog "comparing switch from active to inactive version"
		compare $inactive_version
	
	else
		usage "unknown problem checking for downgrade,$errors"
	fi
}

compare() {

	# Compare active version with other version to see if requested operation is a downgrade
	# ALSO compare inactive version with other version to see if it is already installed 
	# parameter 1: other version to compare to active and inactive versions

	[ $debug -eq 0 ] || writelog "compare running"

	[ $active_version != "undefined" ] && [ $debug -ne 0 ] && writelog "active_version is $active_version"
	[ $inactive_version != "undefined" ] && [ $debug -ne 0 ] &&  writelog "inactive_version is $inactive_version"
	[ $update_version != "undefined" ] && [ $debug -ne 0 ] &&  writelog "update_version is $update_version"

	[ $active_version != "undefined" ] && active=$(normalize $active_version) && active=$(echo $active | sed 's/\.//g')
	[ $inactive_version != "undefined" ] && inactive=$(normalize $inactive_version) && inactive=$(echo $inactive | sed 's/\.//g')
	[ $1 != "undefined" ] && other=$(normalize $1) && other=$(echo $other | sed 's/\.//g')

	[ $debug -eq 0 ] || writelog "active is [$active]"
	[ $debug -eq 0 ] || writelog "inactive is [$inactive]"
	[ $debug -eq 0 ] || writelog "other  is [$other]"

	if [ $active_version != "undefined" ] && [ $1 != "undefined" ]; then

		if [ $active -gt $other ]; then
			writelog "This IS a downgrade:  $active_version -> $1"
			downgrade=1
		else
			writelog "This is NOT a downgrade:  $active_version -> $1"
			downgrade=0
		fi

		[ $inactive_version != "undefined" ] && [ $inactive -eq $other ] && installed=1

	elif [ $1 == "undefined" ]; then
		writelog "UNABLE to evaluate downgrade:  $active_version -> $1"
		downgrade=2
	else
		usage "missing version [active: $active]; [other: $other],$errors"
	fi
}

normalize() {

	# Remove special components from the given version string
	#     and pad maj.min.patch to three digits
	#     and pad the buildnumber to seven digits
	# parameter 1: version string to normalize
	# return normalized version string

	versiona=()
	v=""
	IFS='.' read -ra versiona <<< "$1"
	length=${#versiona[*]}
	last=$length
	let last-=1
	for (( j = 0 ; j < $length ; j++ )); do

		# maybe pad this element to three digits
		esize=${#versiona[$j]}
		while [ $esize -lt 3 ]; do
			versiona[$j]="0${versiona[$j]}"
			esize=${#versiona[$j]}
		done

		if [ $j -eq $last ]; then

			# maybe pad the build number to seven digits
			while [ $esize -lt 7 ]; do
				versiona[$j]="0${versiona[$j]}"
				esize=${#versiona[$j]}
			done

			v="$v${versiona[$j]}"
		elif [ $j -gt 2 ]; then
			continue
		else
			v="$v${versiona[$j]}."
		fi
	done
	echo $v
}

local_sysupdate() {

	# Update to a special build image available locally
	# parameter 1: local path to update image

	writelog "device is $device, local_sysupdate in process"
	check_image_name "$1" 
	check_file "$1"

	image_name=$(basename $1)
	[ $debug -eq 0 ] || writelog "local image name is $image_name"

	is_downgrade $image_name
	[ $debug -gt 0 ] && writelog "downgrade is: $downgrade" && writelog "installed is: $installed"
	[ $downgrade -gt 0 ] && prompt "downgrade $product from $active_version to $update_version"
	[ $installed -gt 0 ] && prompt "reinstall the same version $update_version to the inactive partition"

	# do the update
	run_update $1

	switch_partition
}

url_update() {

	# Update to a special build image available on a web server
	# parameter 1: web server URL of special update image

	writelog "device is $device, url_update in process"
	check_image_name "$1"

	# get the manifest to verify image integrity
	[ $debug -eq 0 ] || writelog "which_manifest"
	manifest=$(which_manifest "$1")
	[ -z $manifest ] && usage "This device is \"$device\" please run this script on target device,$errors"

	#if there already exists a manifest locally, assume it is stale and just delete it
	maybe_delete_manifest

	# get and check the manifest
	get_file $(dirname $1)/$manifest

	check_file_no_exit $update_dir$manifest
	result=$?
	[ $debug -eq 0 ] || writelog "get manifest result is $result"
	if [ $debug -ne 0 ]; then
		[ $result -eq 1 ] && writelog "Manifest missing" || writelog "Manifest present"
	fi

	image_name=$(basename $1)
	[ $debug -eq 0 ] || writelog "url image name is $image_name"

	is_downgrade $image_name
	[ $debug -gt 0 ] && writelog "downgrade is: $downgrade" && writelog "installed is: $installed"
	[ $downgrade -gt 0 ] && prompt "downgrade $product from $active_version to $update_version"
	[ $installed -gt 0 ] && prompt "reinstall the same version $update_version to the inactive partition"

	# get and check image if not already available in the local update directory
	check_file_no_exit $update_dir$image_name
	result=$?
	[ $debug -eq 0 ] || writelog "get update file result is $result"
	if [ $debug -ne 0 ]; then
		[ $result -eq 1 ] && writelog "update file missing" || writelog "update file present"
	fi

	[ $result -eq 1 ] && get_file $1 && check_file $update_dir$image_name

	# if we got this far without a manifest, $quash is greater than 0 and we won't verify... 
	[ $quash -eq 0 ] &&  verify_checksum

	# do the update
	run_update $update_dir$image_name

	switch_partition
}

prompt() {

	# Prompt the user to confirm/decline actions that may have unpleasent side effects
	# parameter 1: prompt string to be presented to user enclosed with 'Do you wish to <parameter>?'
	#     1) Yes or 2) No response needed

	# check auto confirmation 
	[ $aconf -gt 0 ] && writelog "
>>>>>> AUTOCONFIRM: '$1' <<<<<<
" && sleep 1 && return

	echo "
Do you wish to $1?"
	select yn in "Yes" "No"; do
		case $yn in
			[Yy]* ) writelogonly "User confirmed $1"; return;;
			[Nn]* ) writelogonly "User declined $1"; writelogonly "EXIT:  $(basename $0) version: $(version)"; exit 0;;
		esac
	done
}

latest_update() {

	# Update to the latest development build image

	writelog "device is $device, latest_update in process"

	# get and examine the maniest to determine 'latest' version and to verify image integrity
	[ $debug -eq 0 ] || writelog "which_manifest"
	manifest=$(which_manifest)
	[ -z $manifest ] && usage "This device is \"$device\" please run this script on target device,$errors"

	# if there already exists a manifest locally, assume it is stale and just delete it
	maybe_delete_manifest

	# get and check the manifest
	get_latest $manifest
	
	check_file_no_exit $update_dir$manifest
	result=$?
	[ $debug -eq 0 ] || writelog "get manifest result is $result"
	if [ $debug -ne 0 ]; then
		[ $result -eq 1 ] && writelog "Manifest missing" || writelog "Manifest present"
	fi

	image_name=$(get_update_image_name $update_dir$manifest)
	[ $debug -eq 0 ] || writelog "latest image name is $image_name"

	is_downgrade $image_name
	[ $debug -gt 0 ] && writelog "downgrade is: $downgrade" && writelog "installed is: $installed"
	[ $downgrade -eq 1 ] && prompt "downgrade $product from $active_version to $update_version"
	[ $downgrade -eq 2 ] && prompt "update $product from $active_version to UNKNOWN version"
	# if downgrade -eq 2, installed should never be -gt 0
	[ $installed -gt 0 ] && prompt "reinstall the same version $update_version to the inactive partition"

	# check and get image if not already available in the local update directory
	check_file_no_exit $update_dir$image_name
	result=$?
	if [ $debug -ne 0 ]; then
		[ $result -eq 1 ] && writelog "update file missing" || writelog "update file present"
	fi

	[ $result -eq 1 ] && get_latest $image_name && check_file $update_dir$image_name

	verify_checksum

	# do the update
	run_update $update_dir$image_name

	switch_partition
}

local_netupdate() {

	# Update the network module to a special image available locally 
    # parameter 1: local path to network image

	writelog "device is $device, Network local_netupdate not implemented"
	writelogonly "EXIT:  $(basename $0) version: $(version)"
	1>&2; exit 0;
}

run_update() {

	# Figure out which update to run and Just Do It (tm)
	# parameter 1: local path to update image

	[ $device == "wallsly" ] && run_sly_update $1
	[ $device == "slimline" ] && run_slimline_update $1
	[ $device == "touchlink" ] && run_touchlink_update $1
	[ $device == "undefined" ] || [ $device == "other" ] &&
		usage "This device is \"$device\" please run this script on target device,$errors"
}

run_sly_update() {

	# Just Do It (tm) on a Smart Hub
	# parameter 1: local path to update image

	writelog "device is $device, run_sly_update"
	which_inactive
	format_inactive
	extract_to_inactive $1
	validate_inactive_kernel
	replace_ssl_certs
}

run_slimline_update() {

	# Just Do It (tm) on a Glance
	# parameter 1: local path to update image

	writelog "device is $device, run_slimline_update"
	which_inactive
	format_inactive
	extract_to_inactive $1
	validate_inactive_kernel
}

run_touchlink_update() {

	# Just Do It (tm) on a SkyControl
	# parameter 1: local path to update image

	writelog "device is $device, run_touchlink_update"
	which_inactive
	format_inactive
	extract_to_inactive $1
	validate_inactive_kernel
	replace_ssl_certs
}

replace_ssl_certs() {

	# The inactive partition has a fresh installation so copy
	# fresh SSL certificates from there to the persistent location

	[ $debug -eq 0 ] || writelog "replace_ssl_certs"
	writelog "Checking for new ssl_certs at $inactive_part/opt/2gig/ssl_certs"
	if [[ -d $inactive_part/opt/2gig/ssl_certs && -f $inactive_part/opt/2gig/ssl_certs/ca-certificates.crt ]]; then

		if [ $dryrun -eq 0 ]; then
			writelog "Removing previous ssl_certs from /media/extra/ssl_certs"
			if [ -d /media/extra/ssl_certs ]; then
				rm /media/extra/ssl_certs/*
			fi

			writelog "Copying new ssl_certs from $inactive_part/opt/2gig/ssl_certs to /media/extra/ssl_certs"
			if [ ! -d /media/extra/ssl_certs ]; then
				mkdir -p /media/extra/ssl_certs
			fi

			cp -a $inactive_part/opt/2gig/ssl_certs/* /media/extra/ssl_certs/
		else
			writelog "This is a dry run on replace_ssl_certs, nothing changed"
		fi
	else
		writelog " Error: $inactive_part/opt/2gig/ssl_certs not found. Continuing with previous certs"
	fi
}

validate_inactive_kernel() {

	# Validate the kernel installed on the inactive partition 

	if [[ -e $inactive_part'/boot/uImage.md5sum' ]]
	then
		cd $inactive_part'/boot'
		if [[ ! 'OK' == $(/usr/bin/md5sum -c 'uImage.md5sum' | cut -d' ' -f2) ]]
		then
			usage "Inactive kernel checksum did NOT match $(cat 'uImage.md5sum' | cut -d' ' -f1),$errors"
		else
			writelog "Inactive kernel checksum SUCCESS! $(cat 'uImage.md5sum' | cut -d' ' -f1)"
		fi
		cd - 1>&2> /dev/null
	else
		usage "Inactive kernel checksum is missing,$errors"
	fi
}

extract_to_inactive() {

	# Extract the given update image to the inactive partition
	# parameter 1: local path to update image

	[ $debug -eq 0 ] || writelog "extract_to_inactive"
	writelog "Extracting $(basename $1) to $inactive_part Please wait..."

	if [[ $(basename $1) =~ ^.*\.xz$ ]] && [ $(which xz 2>/dev/null) ]; then
		exbin="xz"
	elif [[ $(basename $1) =~ ^.*\.bz2$ ]] && [ $(which bzip2 2>/dev/null) ]; then
		exbin="bzip2"
	else
		writelog "Unsupported archive format $1"
		exit 1
	fi
		
	if [ $(which pv) ]; then
		[ $debug -eq 0 ] || writelog "pv is installed"
		pv -eptrbf -i 1.0 -B 131072 $1 | $exbin -d -c | tar -C $inactive_part -x
	else
		[ $debug -eq 0 ] || writelog "pv is not installed"
		$exbin -d -c $1 | tar -C $inactive_part -x -v
	fi

	status=$?
	[ $status -eq 0 ] || usage "tar returned non zero status \"$status\" extracting the rootfs: $1,$errors"
}

format_inactive() {

	# Format the inactive partition
	# parameter 1: local path to update image	

	[ $debug -eq 0 ] || writelog "format_inactive"

	writelog "Preparing to format $dev_part"
	writelog "Unmount $dev_part..."
	umount $dev_part
	writelog "Create ext4 filesystem on $dev_part"
	mkfs.ext4 -E nodiscard $dev_part
	writelog "Remount $dev_part..."
	mount $dev_part $inactive_part
}

which_inactive() {

	# Figure out which rootfs partition is inactive and which is active (i.e. current)

	[ $debug -eq 0 ] || writelog "which_inactive"
	current_dev_part=$(cat /proc/cmdline | cut -d= -f3 | cut -d' ' -f1)

	if [[ $current_dev_part == '/dev/mmcblk0p6' ]]
	then
		inactive_part=/media/mmcblk0p5
		current_part=/media/mmcblk0p6
		dev_part=/dev/mmcblk0p5
	elif [[ $current_dev_part == '/dev/mmcblk0p5' ]]
	then
		inactive_part=/media/mmcblk0p6
		current_part=/media/mmcblk0p5
		dev_part=/dev/mmcblk0p6
	else
		usage "Can't identify inactive rootfs partition,$errors"
	fi
	[ $debug -eq 0 ] || writelog "inactive partition is $inactive_part"
}

which_manifest() {
	# return the manifest name

	local MANIFEST
	[ $device == "wallsly" ] && MANIFEST="slyupdt"
	[ $device == "slimline" ] && MANIFEST="slimupdt"
	[ $device == "touchlink" ] && MANIFEST="2gigupdt"
	if [ $device == "other" ] || [ $device == "unknown" ] ; then
		echo ""
		return
	fi
	if [[ "$1" =~ \.xz$ ]] ; then
		MANIFEST="${MANIFEST}-xz.txt"
	else
		MANIFEST="${MANIFEST}.txt"
	fi
	echo "$MANIFEST"
}

maybe_delete_manifest() {

	# Delete the manifest if it exists

	[ $debug -eq 0 ] || writelog "maybe_delete_manifest"
	[ $debug -ne 0 ] && [ -f $update_dir$manifest ] && writelog "deleting previous local manifest $update_dir$manifest"
	[ -f $update_dir$manifest ] && rm -f $update_dir$manifest
}

set_active_version() {

	# Set the local active version based on /etc/version

	[ $debug -eq 0 ] || writelog "set_active_version running"
	[ -f /etc/version ] && active_version=$(cat /etc/version | cut -d' ' -f2)
	[ $debug -eq 0 ] || writelog "active version is $active_version"
}

set_inactive_version() {

	# Set the local inactive version based on $inactive_part/etc/version

	[ $debug -eq 0 ] || writelog "set_inactive_version running"
	which_inactive
	[ -f $inactive_part/etc/version ] && inactive_version=$(cat $inactive_part/etc/version | cut -d' ' -f2)
	[ $debug -eq 0 ] || writelog "inactive version is $inactive_version"
}

# Test file names:
# sly-qt5-image-imx6dl-slimline-3.19.4.staging.28619.rootfs.tar.xz
# slimline-qt5-image-imx6dl-slimline-3.19.4.sta-ging.28619.rootfs.tar.bz2
# slimline-qt5-image-imx6dl-slimline-3.19.4.staging.28619.rootfs.tar.gz
# slimline-qt5-image-imx6dl-slimline-3.19.4.stagi-ng.28619.rootfs.tar.xz
# slimline-usb-image-update-3.19.4.staging.28619.sha256 -> undefined
# slimline-usb-image-update-3.19.4.staging.28619.zip -> undefined
# sly-qt5-image-imx6dl-slimline-3.19.4.staging.28619.rootfs.tar.bz2
# sly-qt5-image-imx6dl-slimline-3.19.4.staging.28619.rootfs.tar.gz
# sly-qt5-image-imx6dl-slimline-3.19.4.staging.28619.rootfs.tar.xz
# sly-usb-image-update-3.19.4.staging.28619.sha256 -> undefined
# sly-usb-image-update-3.19.4.staging.28619.zip -> undefined
# touchlink-qte-image-glibc-ipk-3.19.4.stag_ing.28619-touchlink.rootfs.tar.bz2
# touchlink-qte-image-glibc-ipk-3.19.4.stag-ing.28619-touchlink.rootfs.tar.xz
get_version_from_image_name() {
	# Get the update version from the given image name
	#   - to avoid dependency on manifest
	# parameter 1: image name
	# return the version

	v="$1"
	rootfsmatcher="rootfs[.]tar[.](xz|bz2|gz)$"
	if [[ $v =~ $rootfsmatcher ]]; then
		v=$(echo "$v" | sed -e 's/^.*\(slimline\|glibc-ipk\)-//' -e 's/\(-touchlink\)\?.rootfs.tar.*$//')
		echo "$v"
	else
		echo "undefined"
	fi
}

get_update_image_name() {

	# Get the update image name from the given manifest if it exists
	# parameter 1: local path to the manifest
	# return the image name

	name=$(cat $1 | grep "File" | cut -d' ' -f2)
	result=$?
	if [ $result -ne 0 ] || [ ! $name ]; then
		echo "undefined"
	fi
	echo $name
}

get_update_image_version() {

	# Get the update image version from the given manifest if it exists
	# parameter 1: local path to the manifest
	# return the image version

	version=$(cat $1 | grep "Version" | cut -d' ' -f2)
	result=$?
	if [ $result -ne 0 ] || [ ! $version ]; then
		echo "undefined"
	fi
	echo $version
}

get_checksum() {

	# Get the update image checksum from the given manifest if it exists
	# parameter 1: local path to the manifest
	# retun the manifest checksum value if it exists, otherwise 'undefined'

	checksum=$(cat $1 | grep "Checksum" | cut -d' ' -f2)
	result=$?
	if [ $result -ne 0 ] || [ ! $checksum ]; then
		echo "undefined"
	fi
	echo $checksum
}

verify_checksum() {

	# Verify the manifest checksum matches the update image
	# If the checksum fails delete the update image and report the error 

	[ $debug -eq 0 ] || writelog "get_checksum "$update_dir$manifest
	checksum=$(get_checksum $update_dir$manifest)
	[ $debug -eq 0 ] || writelog "image_checksum "$update_dir$image_name
	writelog "Computing checksum for $image_name Please wait..."
	image_checksum=$(image_checksum $update_dir$image_name)
	if [ $checksum != $image_checksum ]; then
		rm -f $update_dir$image_name
		[ $latest -eq 1 ] && [ $checksum == "undefined" ] &&
			usage "whoops!! Manifest checksum is '$checksum' how did we get here? This should have been caught earlier when updating to latest,$errors"
		usage "checksum '$checksum' does not match image '$image_checksum' please try again,$errors"
	else
		writelog "Manifest checksum $checksum matches image $image_checksum"
	fi
}

image_checksum() {
	
	# Compute the update image checksum if it exists
	# parameter 1: local path to the update image
	# return the image checksum if it exists, otherwise 'undefined'

	if [ -f $1 ]; then
		echo $(md5sum $1 | cut -d' ' -f1)
	else
		echo "undefined"
	fi
}

get_file() {

	# Get a remote file
	# parameter 1: web server URL of the file
	# return curl exit code

	[ $debug -eq 0 ] || writelog "get_file $1"
	(cd $update_dir && curl -L -O "$1")
	result="$?"
	[ $debug -eq 0 ] || writelog "curl file result is '$result'"

	if [ $result -ne 0 ]; then

		# if this is 'update to the latest' then fail fast,
		# there is no good way to get the image without knowing the image name
		[ $latest -eq 1 ] && [ $manifest == $(basename $1) ] &&
			usage "Failed to get manifest at 'latest build' location - cannot proceed,$errors"

		# if the file is a manifest, prompt user then set quash directive to skip image checksum
		if [ $manifest == $(basename $1) ]; then
			prompt "continue with the update manifest missing (no image integtity check)"
			writelog "Manifest missing, continuing without checksum validation"
			quash=1
			return 0
		fi

		# delete the attempted download file, it is probably corrupt
		if [ -f $update_dir$(basename $1) ]; then
			rm $update_dir$(basename $1)
		fi

		# check disk usage
		usage=$(df |grep /media/extra | cut -c 51-54 | xargs)
		if [ $usage -gt 99 ]; then

			# out of space, offer to clean it up	
			writelog "
 >>>>>>> It appears you are   OUT OF SPACE   on /media/extra <<<<<<<
			"
			df -h
			prompt "delete all files in $update_dir to free space and retry the download"
			[ $update_dir == "/media/extra/update/" ] && rm $update_dir*
			
			# retry download of image and manifest
			retry_count=$((retry_count+1))
			[ $retry_count -lt 5 ] && get_file $(dirname $1)/$manifest && get_file $1 || usage "exceeded get_file retry count.$errors"
		fi

		# check the result again in case this was a retry
		if [ $result -ne 0 ]; then
			usage "$result Failed to download $1 exit code $result,$errors"
		fi
	fi
	return $result # to satisfy caller's conditional construct
}

get_latest() {

	# Get a the latest remote file
	# parameter 1: name of file to get from latest build location

	[ $debug -eq 0 ] || writelog "get_latest $latest_url$1"
	[ $1 ] && get_file $latest_url$1 || usage "Could not get $latest_url$1,$errors"
}

check_file() {

	# Verify a file exists and exit if there is an error
	# parameter 1: local location/name of file	

	[ $debug -eq 0 ] || writelog "check_file \"$1\""
	[ -f $1 ] || usage "File not found $1,$errors"
}

check_file_no_exit() {

	# Verify a file exists without exiting if there is an error
	# parameter 1: local location/name of file  
	# return 0 if file exists otherwse return 1

	[ $debug -eq 0 ] || writelog "check_file_no_exit \"$1\""
	[ -f $1 ] && return 0
	return 1
}

check_image_name() {

	# Make sure the image name matches this device
    # parameter 1: location/name of update image

	image_name=$(basename $1)

	[ $debug -eq 0 ] || writelog "check_image_name running"
	[ $device == "wallsly" ] && check_image_name_wallsly "$image_name"
	[ $device == "slimline" ] && check_image_name_slimline "$image_name"
	[ $device == "touchlink" ] && check_image_name_touchlink "$image_name"
	[ $device == "other" ] && usage "This device is \"$device\" please run this script on target device,$errors"
	[ $device == "unknown" ] && usage "This device is \"$device\" please run this script on target device,$errors"
	[ $device == "" ] && usage "Unkown problem while checking image name,$errors"
}

check_image_name_wallsly() {

	# Make sure the image name matches Smart Hub
	# parameter 1: name of update image

	[ $debug -eq 0 ] || writelog "check_image_name_wallsly running"
	if [[ $1 == $wallsly_image ]]; then
		[ $debug -eq 0 ] || writelog "GOOD image name for a $product - $1"
	else
		echo "Invalid image name \"$1\" for $product,$errors"
		exit 1
	fi
}

check_image_name_slimline() {

	# Make sure the image name matches Glance
	# parameter 1: name of update image
    
	[ $debug -eq 0 ] || writelog "check_image_name_slimline running"
	if [[ $1 == $slimline_image ]]; then
		[ $debug -eq 0 ] || writelog "GOOD image name for a $product - $1"
	else
		echo "Invalid image name \"$1\" for $product,$errors"
		exit 1
	fi
}

check_image_name_touchlink() {

	# Make sure the image name matches this SkyControl
	# parameter 1: name of update image
    
	[ $debug -eq 0 ] || writelog "check_image_name_touchlink running"
	if [[ $1 == $touchlink_image ]]; then
		[ $debug -eq 0 ] || writelog "GOOD image name for a $product - $1"
	else
		echo "Invalid image name \"$1\" for $product,$errors"
		exit 1
	fi
}

version() {

	if [ -f $(basename $0) ]; then
		echo $(md5sum $(basename $0) | cut -d' ' -f1)$version
	elif [ -f /usr/local/bin/$(basename $0) ]; then
		echo $(md5sum /usr/local/bin/$(basename $0) | cut -d' ' -f1)$version
	else
		echo "custom$version"
	fi
}

main "$@"

