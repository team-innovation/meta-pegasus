#!/bin/bash
set -x

DEBUG=yes
#DEBUG=no
QUIET=no
SCRIPTNAME=$(basename $BASH_SOURCE)
set -e

echo "$SCRIPTNAME"

BOARDNAME=slimline
DRIVE=/dev/mmcblk0
BSPART=/dev/mmcblk0p3
BOOTNUM1ROOTPART=/dev/mmcblk0p5
BOOTNUM2ROOTPART=/dev/mmcblk0p6

# Utility functions
carp() {
	echo "$SCRIPTNAME: fatalerror: $1"
	exit 1
}

usage() {
	carp "usage: $SCRIPTNAME no-clue?????"
}

info() {
	test "$QUIET" == "yes" ||
		echo "$SCRIPTNAME: $1"
}

# board identification helpers
is_slimline() {
	grep -q vivint,slimline "/proc/device-tree/compatible"
}

is_sly() {
	grep -q vivint,sly "/proc/device-tree/compatible"
}

is_wallsly() {
	grep -q vivint,wallsly "/proc/device-tree/compatible"
}

#
# The bootscript and serial number are in the bootscript partition
#

# Some functions for (un)mounting the boot script partition
# read-only and read/write
#
mntbootscript()
{
	mount | grep -q ${BSPART} ||
		mount ${BSPART}
}

umntbootscript()
{
	mount | grep -q ${BSPART} &&
		umount ${BSPART}
}

mntbootscriptrw()
{
	mount ${BSPART} -o remount,rw,sync ||
		carp "unable to mount ${BSPART} read/write"
}

mntbootscriptro()
{
	mount ${BSPART} -o remount,ro ||
		carp "unable to mount ${BSPART} read/only"
}

# does bootscript match one in rootfs
bootscrcheck() {
	local rv

	mntbootscript
	cmp -s /media/bootscript/boot.scr /boot/boot.scr
	rv=$?
	return $rv
}

# update bootscript
bootscrupdate() {
	mntbootscriptrw
	cp /boot/boot.scr /media/bootscript/boot.scr
	sync
	mntbootscriptro
	true

}

# is there a serial number file
serialnumcheck() {
	local sn=""

	mntbootscript
	test -f /media/bootscript/serialnumber.txt &&
		sn=$(cat /media/bootscript/serialnumber.txt)

	test -n "${sn}"
}

# warn about no serialnumber
serialnumwarn() {
	info "board has no serial number, which is normal for first boot"
	true
}

# The u-boot bootloader lives in the first eMMC boot partition, known in linux
# as /dev/mmcblk0boot0.  The u-boot environment lives in the second eMMC boot
# partition known in linux as /dev/mmcblk0boot1
#

# Utility functions to enable/disable writing to eMMC boot partitions
emmcrw() {
	local num=$1
	echo 0 > /sys/block/mmcblk0boot${num}/force_ro
}

emmcro() {
	local num=$1
	echo 1 > /sys/block/mmcblk0boot${num}/force_ro
}

# slimline and sly share a common u-boot binary
# wallsly has a specific version
ubootbinary() {
	is_slimline &&
		echo "/boot/u-boot.imx" &&
		return
	is_sly &&
		echo "/boot/u-boot.imx" &&
		return
	is_wallsly &&
		echo "/boot/u-boot-wallsly.imx" &&
		return
	carp "unsupported platform looking for u-boot binary"
}

# Is u-boot in boot partition same version as one in rootfs
ubootcheck() {
	vold=$(strings /dev/mmcblk0boot0 | grep "U-Boot.20")
	vnew=$(strings $(ubootbinary) | grep "U-Boot.20")
	test "$vold" = "$vnew"
}

#
ubootupdate() {
	emmcrw 0
	dd if=/dev/zero of=/dev/mmcblk0boot0 bs=1024 count=2048
	dd if=$(ubootbinary) of=/dev/mmcblk0boot0 bs=512 seek=2
	sync
	emmcro 0

	# clearing u-boot env loses bootnum so leave it alone
	true
}


# eMMC has bits that set boot modes.  These need to be set so the
# eMMC chip agrees with the processor on how the bus is configured
# at boot time.  These bits are accessed from a file in sysfs.
# Details here, skip to TL;DWR for succinct version.
#
# The sysfs directory containing the files we need is
# /sys/devices/soc0/soc.0/2100000.aips-bus/219c000.usdhc/mmc_host/mmc0/mmc0:0001
# But use find and grep to set it.
#
mmcbootconfigdir=$(find /sys/devices -type d | grep 'mmc.:0001$')

# The first file to write is boot_bus_config.  We need to set it up like this:
# boot_bus:0x0a
#   BOOT_MODE:1 - Use single data rate + high speed timings in boot
#                 operation mode
#   RESET_BOOT_BUS_WIDTH:0 - Reset bus width to x1, single data rate and
#                            backwardcompatible timings after boot operation
#   BOOT_BUS_WIDTH:2 - x8 (sdr/ddr) bus width in boot operation mode
# However the file expects the value in decimal not hex so:
MMC_BOOT_BUS_VAL=10

# The second file to write is boot_config, the bits here choose the boot partition
# we use boot partition 1 of 2 (or 0 in linux device numbering)
#
# this is confusing again because of hex/decimal
# from the source we have this comment:
#
# 0x00 - disable boot enable.
# 0x08 - boot partition 1 is enabled for boot.
# 0x10 - boot partition 2 is enabled for boot.
# 0x38 - User area is enabled for boot.
#
# If you do the right stupid thing you might get this helpful message that is
# a hint that the author really liked decimal over hex:
#
#   wrong boot config parameter 00 (disable boot), 08 (enable boot1),
#					... 16 (enable boot2), 56 (User area)
#
# we want boot partition 1(aka 0) so we use 8 which is the same for hex and decimal
MMC_BOOT_CONFIG_VAL=8

# To get the current config we need to read the file boot_info
# in the directory determined above.
# Here is the raw dump of this file on a system with the correct settings
# already applied:

# boot_info:0x07;
# ALT_BOOT_MODE:1 - Supports alternate boot method
# DDR_BOOT_MODE:1 - Supports alternate dual data rate during boot
# HS_BOOTMODE:1 - Supports high speed timing during boot
# boot_size:2048KB
# boot_partition:0x48;
# BOOT_ACK:1 - Boot acknowledge sent during boot operation
# BOOT_PARTITION-ENABLE: 1 - Boot partition 1 enabled
# boot_bus:0x0a
# BOOT_MODE:1 - Use single data rate + high speed timings in boot operation mode
# RESET_BOOT_BUS_WIDTH:0 - Reset bus width to x1, single data rate and
# 			... backwardcompatible timings after boot operation
# BOOT_BUS_WIDTH:2 - x8 (sdr/ddr) bus width in boot operation mode

# To verify settings we check just two fields:
# 1) BOOT_PARTITION-ENABLE: 1 corresponds to MMC_BOOT_CONFIG_VAL=8 above
# and 2) boot_bus:0xa corresponds to MMC_BOOT_BUS_VAL=10 above


# TL;DWR (Too Long; Don't Wanna Read)
#   Make eMMC boot partition writeable
#   Sleep a bit
#   Find the directory for eMMC using find and grep.
#   Write 10 to boot_bus_config in directory found above.
#   Sleep a bit
#   Write 8 to boot_config in directory found above.
#   Sleep a bit
#   Read boot_info in directory found above to verify.
#

# Utility function to grab a matching field
boot_info_field() {
	local match=$1;
	sed -n s/$match//p ${mmcbootconfigdir}/boot_info
}

# see above
mmcbootbitscheck() {
	local f1
	local f2
	f1=$(boot_info_field "boot_bus:")
	f2=$(boot_info_field ".*BOOT_PARTITION-ENABLE:.1.-.")
	test "${f1}" = "0x0a" ||
		return 1
	test "${f2}" = "Boot partition 1 enabled" ||
		return 1
	true
}

# see above
mmcbootbitsset() {
	emmcrw 0
	emmcrw 1
	usleep 500000
	echo ${MMC_BOOT_BUS_VAL} > ${mmcbootconfigdir}/boot_bus_config
	usleep 500000
	echo ${MMC_BOOT_CONFIG_VAL} > ${mmcbootconfigdir}/boot_config
	usleep 500000
	emmcro 0
	emmcro 1
	true
}

# slimline has no board boot jumper to set boot mode
# all boot config is set in i.mx6 fuses aka
# ocotp -- On Chip One Time Programmable

# the boot fuses necessary to boot from eMMC are:
# BOOT_CONFIG1[7:6] = 01  - Boot from USDHC Interfaces
# BOOT_CONFIG1[5]   = 1   - MMC/eMMC
# BOOT_CONFIG1[4]   = 1   - Fast Boot
#
# BOOT_CONFIG1[7 6 5 4 3 2 1 0]
#              0 1 1 1 0 0 0 0 = 0x70
#
# BOOT_CONFIG2[7:5] = 010 - 8-bit
# BOOT_CONFIG2[4:3] =
#		      11  - USDHC-4
#		      10  - USDHC-3
#		      01  - USDHC-2
#		      00  - USDHC-4
#
# BOOT_CONFIG2[7 6 5 4 3 2 1 0]
#              0 1 0 1 1 0 0 0 = 0x58  - USDHC-4
#              0 1 0 1 0 0 0 0 = 0x50  - USDHC-3
#              0 1 0 0 1 0 0 0 = 0x48  - USDHC-2
#              0 1 0 0 0 0 0 0 = 0x40  - USDHC-1
#
# HW_OCOTP_CFG4 contains [boot_config4:boot_config3:boot_config2:boot_config1]
#

# use mmc0 sysclass link to find physical usdhc interface
boot_config2()
{
	bc2=0x0
	mmcdev=$(readlink /sys/class/mmc_host/mmc0) ||
		carp "unable to read mmc0 device link"
	case "$mmcdev" in
		*219c000.usdhc*)
			bc2=0x58;
			;;
		*2198000.usdhc*)
			bc2=0x50;
			;;
		*2194000.usdhc*)
			bc2=0x48;
			;;
		*2190000.usdhc*)
			bc2=0x40;
			;;
		*)
			carp "bad mmcdev $mmcdev"
			;;
	esac
	echo $bc2
}

hw_ocotp_cfg4_val()
{
	printf "0x%04x\n" $(( $(boot_config2) << 8 | 0x70 ))
}

# BT_FUSE_SEL is the fuse that indicates that boot settings are in
# the fuses (it is a special case so this is not really recursive)
# BT_FUSE_SEL is bit 4 (1 << 4 == 0x10) in HW_OCOTP_CFG5
#
hw_ocotp_cfg5_val()
{
	echo 0x10
}


fusecheck()
{
	local f
	f=$(cat /sys/fsl_otp/HW_OCOTP_CFG4)
	test "${f}" = "$(hw_ocotp_cfg4_val)" ||
		return 1
	f=$(cat /sys/fsl_otp/HW_OCOTP_CFG5)
	test "${f}" = "$(hw_ocotp_cfg5_val)" ||
		return 1
	true
}

fuseset()
{
	hw_ocotp_cfg4_val > /sys/fsl_otp/HW_OCOTP_CFG4
	hw_ocotp_cfg5_val > /sys/fsl_otp/HW_OCOTP_CFG5
	true
}

must_succeed()
{
	cmd=$1
	eval "${cmd}" &&
		info "${cmd} succeeded" &&
		return
	carp "${cmd} failed"
}

succeed_or()
{
	checkcmd=$1
	eval "${checkcmd}" &&
		info "${checkcmd} succeeded" &&
		return
	dothis=$2
	info "${checkcmd} failed... calling ${dothis}" &&
	must_succeed ${dothis}
	info "verifying with ${checkcmd}"
	must_succeed ${checkcmd}
}

fusecheck || {
	info "This is a new board, will halt after fuse and emmc setup"
	export FACTORYFIRSTBOOT="true"
}

function chk_rev()
{
        local result=$(fw_printenv board)
        case "${result##*=}" in
                WallSly-net|WallSly-v3|WallSly-v4|WallSly-v6)
                        echo "8.19"
                        ;;
                *)
                        echo "A.0"
                        ;;
        esac
}

addboardmodelfromdevtree() {
	pit="/media/bootscript/panelinfo.txt"

	is_slimline &&
		echo 'export SL_BOARD_MODEL="28-600015-001"' >> $pit &&
		return
	is_sly &&
		echo 'export SH_BOARD_MODEL="28-600052-001"' >> $pit &&
		return
	is_wallsly &&
	        grep -q 28-FIX-ME $pit &&
        	if [ $? -eq 0 ]; then
                	sed --in-place '/28-FIX-ME/d' $pit
	        fi 
        	echo "export WS_BOARD_MODEL="28-600060-001-$(chk_rev)"" >> $pit  &&
		return
}

addboardrevfromdevtree() {
	pit="/media/bootscript/panelinfo.txt"

	is_slimline &&
		echo 'export SL_BOARD_REV="V-SHD1-A13"' >> $pit &&
		return
	is_sly &&
		echo 'export SH_BOARD_REV="V-SH1-A0"' >> $pit &&
		return
	is_wallsly &&
	        grep -q V-FIX-ME $pit &&
        	if [ $? -eq 0 ]; then
                	sed --in-place '/V-FIX-ME/d' $pit
	        fi 
        	echo "export WS_BOARD_REV="VS-SH2000-000-Rev-$(chk_rev)"" >> $pit &&
		return
}

panelinfoboardmodelcheck() {
	mntbootscript
	pit="/media/bootscript/panelinfo.txt"

	test -f $pit ||
		return $(false)
	grep -q FIX-ME $pit
	if [ $? -eq 0 ]; then
		mntbootscriptrw
		addboardmodelfromdevtree
		mntbootscriptro
	fi
	grep -q _BOARD_MODEL $pit
}

panelinfoboardrevcheck() {
	mntbootscript
	pit="/media/bootscript/panelinfo.txt"

	test -f $pit ||
		return $(false)
	grep -q FIX-ME $pit
	if [ $? -eq 0 ]; then
		mntbootscriptrw
		addboardrevfromdevtree
		mntbootscriptro
	fi
	grep -q _BOARD_REV $pit
}

panelinfoboardmodelupdate() {
	pit="/media/bootscript/panelinfo.txt"
	mntbootscriptrw
	grep -v .._BOARD_MODEL $pit > /tmp/panelinfo.new
	mv /tmp/panelinfo.new $pit
	addboardmodelfromdevtree
	mntbootscriptro
}

panelinfoboardrevupdate() {
	pit="/media/bootscript/panelinfo.txt"
	mntbootscriptrw
	grep -v .._BOARD_rev $pit > /tmp/panelinfo.new
	mv /tmp/panelinfo.new $pit
	addboardrevfromdevtree
	mntbootscriptro
}

succeed_or bootscrcheck bootscrupdate
succeed_or ubootcheck ubootupdate
succeed_or mmcbootbitscheck mmcbootbitsset
succeed_or fusecheck fuseset

test "${FACTORYFIRSTBOOT}" = "true" && {
	info "Initial factory board setup complete -- halting!"
	sync
	halt -f
}

succeed_or serialnumcheck serialnumwarn
succeed_or panelinfoboardmodelcheck panelinfoboardmodelupdate
succeed_or panelinfoboardrevcheck panelinfoboardrevupdate

info "board re-setup complete, not first time, continuing normal boot..."

exit 0
