#!/bin/bash
set -x

QUIET=no
SCRIPTNAME=$(basename "${BASH_SOURCE[0]}")
set -e

echo "$SCRIPTNAME"

modprobe board_info
BSPART=/dev/mmcblk0p3

# Utility functions
carp() {
	echo "$SCRIPTNAME: fatalerror: $1"
	exit 1
}

usage() {
	carp "usage: $SCRIPTNAME no-clue?????"
}

info() {
	test "$QUIET" == "yes" ||
		echo "$SCRIPTNAME: $1"
}

# board identification helpers
is_slimline() {
	grep -q vivint,slimline "/proc/device-tree/compatible"
}

is_sly() {
	grep -q vivint,sly "/proc/device-tree/compatible"
}

is_wallsly() {
	grep -q vivint,wallsly "/proc/device-tree/compatible"
}

is_brazen() {
	grep -q vivint,brazen "/proc/device-tree/compatible" &&
		test $(cat /sys/class/board_info/board_info/board_rev) -gt 13
}

#
# The bootscript and serial number are in the bootscript partition
#

# Some functions for (un)mounting the boot script partition
# read-only and read/write
#
mntbootscript()
{
	mount | grep -q ${BSPART} ||
		mount ${BSPART}
}

umntbootscript()
{
	mount | grep -q ${BSPART} &&
		umount ${BSPART}
}

mntbootscriptrw()
{
	mount ${BSPART} -o remount,rw,sync ||
		carp "unable to mount ${BSPART} read/write"
}

mntbootscriptro()
{
	mount ${BSPART} -o remount,ro ||
		carp "unable to mount ${BSPART} read/only"
}

# does bootscript match one in rootfs
bootscrcheck() {
	local rv

	mntbootscript
	cmp -s /media/bootscript/boot.scr /boot/boot.scr
	rv=$?
	return $rv
}

# update bootscript
bootscrupdate() {
	mntbootscriptrw
	cp /boot/boot.scr /media/bootscript/boot.scr
	sync
	mntbootscriptro
	true

}

# is there a serial number file
serialnumcheck() {
	local sn=""

	mntbootscript
	test -f /media/bootscript/serialnumber.txt &&
		sn=$(cat /media/bootscript/serialnumber.txt)

	test -n "${sn}"
}

# warn about no serialnumber
serialnumwarn() {
	info "board has no serial number, which is normal for first boot"
	true
}

# The u-boot bootloader lives in the first eMMC boot partition, known in linux
# as /dev/mmcblk0boot0.  The u-boot environment lives in the second eMMC boot
# partition known in linux as /dev/mmcblk0boot1
#

# Utility functions to enable/disable writing to eMMC boot partitions
emmcrw() {
	local num=$1
	echo 0 > /sys/block/mmcblk0boot"${num}"/force_ro
}

emmcro() {
	local num=$1
	echo 1 > /sys/block/mmcblk0boot"${num}"/force_ro
}

# slimline and sly share a common u-boot binary
# wallsly has a specific version
ubootbinary() {
	is_slimline &&
		echo "/boot/u-boot.imx" &&
		return
	is_sly &&
		echo "/boot/u-boot.imx" &&
		return
	is_wallsly &&
		echo "/boot/u-boot-wallsly.imx" &&
		return
	is_brazen &&
		echo "/boot/u-boot-brazen.imx" &&
		return

	carp "unsupported platform looking for u-boot binary"
}

# Is u-boot in boot partition same version as one in rootfs
ubootcheck() {
	vold=$(strings /dev/mmcblk0boot0 | grep "U-Boot.20")
	vnew=$(strings "$(ubootbinary)" | grep "U-Boot.20")
	test "$vold" = "$vnew"
}

#
ubootupdate() {
	emmcrw 0
	dd if=/dev/zero of=/dev/mmcblk0boot0 bs=1024 count=2048
	dd if="$(ubootbinary)" of=/dev/mmcblk0boot0 bs=512 seek=2
	sync
	emmcro 0

	# clearing u-boot env loses bootnum so leave it alone
	true
}


# eMMC has bits that set boot modes.  These need to be set so the
# eMMC chip agrees with the processor on how the bus is configured
# at boot time.  
#   Make eMMC boot partition writeable
#   Sleep a bit
#   Find the directory for eMMC using find and grep.
#   Write 0x0a to boot_bus_config in directory found above.
#   Sleep a bit
#   Write 0x48 to boot_config in directory found above.
#   Sleep a bit
#   Read boot_info in directory found above to verify.
#

# Utility function to grab a matching field
boot_info_field() {
	local ret
	local match=$1;
	ret=$(mmc extcsd read /dev/mmcblk0 | sed -n "s/$match//p")
	echo ${ret%]}
}

# see above
mmcbootbitscheck() {
	local f1
	local f2
	f1=$(boot_info_field ".*BOOT_BUS_CONDITIONS: ")
	f2=$(boot_info_field ".*PARTITION_CONFIG: ")
	test "${f1}" = "0x0a" ||
		return 1
	test "${f2}" = "0x48" ||
		return 1
	true
}

# see above
mmcbootbitsset() {
	emmcrw 0
	emmcrw 1
	usleep 500000
	mmc bootbus set single_hs x1 x8 /dev/mmcblk0
	usleep 500000
	mmc bootpart enable 1 1 /dev/mmcblk0
	usleep 500000
	emmcro 0
	emmcro 1
	true
}

# slimline has no board boot jumper to set boot mode
# all boot config is set in i.mx6 fuses aka
# ocotp -- On Chip One Time Programmable

# the boot fuses necessary to boot from eMMC are:
# BOOT_CONFIG1[7:6] = 01  - Boot from USDHC Interfaces
# BOOT_CONFIG1[5]   = 1   - MMC/eMMC
# BOOT_CONFIG1[4]   = 1   - Fast Boot
#
# BOOT_CONFIG1[7 6 5 4 3 2 1 0]
#              0 1 1 1 0 0 0 0 = 0x70
#
# BOOT_CONFIG2[7:5] = 010 - 8-bit
# BOOT_CONFIG2[4:3] =
#		      11  - USDHC-4
#		      10  - USDHC-3
#		      01  - USDHC-2
#		      00  - USDHC-4
#
# BOOT_CONFIG2[7 6 5 4 3 2 1 0]
#              0 1 0 1 1 0 0 0 = 0x58  - USDHC-4
#              0 1 0 1 0 0 0 0 = 0x50  - USDHC-3
#              0 1 0 0 1 0 0 0 = 0x48  - USDHC-2
#              0 1 0 0 0 0 0 0 = 0x40  - USDHC-1
#
# HW_OCOTP_CFG4 contains [boot_config4:boot_config3:boot_config2:boot_config1]
#

# use mmc0 sysclass link to find physical usdhc interface
boot_config2()
{
	bc2=0x0
	mmcdev=$(readlink /sys/class/mmc_host/mmc0) ||
		carp "unable to read mmc0 device link"
	case "$mmcdev" in
		*219c000.usdhc*)
			bc2=0x58;
			;;
		*2198000.usdhc*)
			bc2=0x50;
			;;
		*2194000.usdhc*)
			bc2=0x48;
			;;
		*2190000.usdhc*)
			bc2=0x40;
			;;
		*)
			carp "bad mmcdev $mmcdev"
			;;
	esac
	echo $bc2
}

hw_ocotp_cfg4_val()
{
	printf "0x%04x\n" $(( $(boot_config2) << 8 | 0x70 ))
}

# BT_FUSE_SEL is the fuse that indicates that boot settings are in
# the fuses (it is a special case so this is not really recursive)
# BT_FUSE_SEL is bit 4 (1 << 4 == 0x10) in HW_OCOTP_CFG5
#
hw_ocotp_cfg5_val()
{
	echo 0x10
}


fusecheck()
{
	local f
	f=$(cat /sys/fsl_otp/HW_OCOTP_CFG4)
	test "${f}" = "$(hw_ocotp_cfg4_val)" ||
		return 1
	f=$(cat /sys/fsl_otp/HW_OCOTP_CFG5)
	test "${f}" = "$(hw_ocotp_cfg5_val)" ||
		return 1
	true
}

fuseset()
{
	hw_ocotp_cfg4_val > /sys/fsl_otp/HW_OCOTP_CFG4
	hw_ocotp_cfg5_val > /sys/fsl_otp/HW_OCOTP_CFG5
	true
}

must_succeed()
{
	cmd=$1
	eval "${cmd}" &&
		info "${cmd} succeeded" &&
		return
	carp "${cmd} failed"
}

succeed_or()
{
	checkcmd=$1
	eval "${checkcmd}" &&
		info "${checkcmd} succeeded" &&
		return
	dothis=$2
	info "${checkcmd} failed... calling ${dothis}" &&
	must_succeed "${dothis}"
	info "verifying with ${checkcmd}"
	must_succeed "${checkcmd}"
}

fusecheck || {
	info "This is a new board, will halt after fuse and emmc setup"
	export FACTORYFIRSTBOOT="true"
}

function chk_board()
{
	local result
	read result </sys/class/board_info/board_info/board_rev
	case "$result" in
		13)
			echo "C00"
			;;
		*)
			echo "000"
			;;
	esac
}

function chk_rev()
{
	local result
	read result </sys/class/board_info/board_info/board_rev
	case "$result" in
		9|10|11|12|13)
			echo "8.19"
			;;
		*)
			echo "A.0"
			;;
	esac
}

addboardmodelfromdevtree() {
	pit="/media/bootscript/panelinfo.txt"

	is_slimline &&
		echo 'export SL_BOARD_MODEL="28-600015-001"' >> $pit &&
		return
	is_sly &&
		echo 'export SH_BOARD_MODEL="28-600052-001"' >> $pit &&
		return
	is_wallsly &&
		sed --in-place '/28-FIX-ME/d' $pit &&
	    	echo export WS_BOARD_MODEL=28-600060-001-"$(chk_rev)" >> $pit  &&
		return
	is_brazen &&
		echo export BRAZEN_BOARD_MODEL=PCB-600021-001-"$(chk_rev)" >> $pit  &&
		return

}

addboardrevfromdevtree() {
	pit="/media/bootscript/panelinfo.txt"

	is_slimline &&
		echo 'export SL_BOARD_REV="V-SHD1-A13"' >> $pit &&
		return
	is_sly &&
		echo 'export SH_BOARD_REV="V-SH1-A0"' >> $pit &&
		return
	is_wallsly &&
		sed --in-place '/V-FIX-ME/d' $pit &&
		echo export WS_BOARD_REV=VS-SH2000-"$(chk_board)"-Rev-"$(chk_rev)" >> $pit &&
		return
	is_brazen &&
		echo export BRAZEN_BOARD_REV=VS-HD1000-"$(chk_board)"-Rev-"$(chk_rev)" >> $pit &&
		return

}

panelinfoboardmodelcheck() {
	mntbootscript
	pit="/media/bootscript/panelinfo.txt"

	test -f $pit ||
		return "$(false)"

	is_wallsly &&
		BMODEL="28-600060-001-$(chk_rev)"
	is_brazen &&
		BMODEL="PCB-600021-001-$(chk_rev)"

	if ! grep -q "$BMODEL" "$pit"; then
		mntbootscriptrw
		sed --in-place '/_BOARD_MODEL/d' $pit
		mntbootscriptro
	fi
	grep -q _BOARD_MODEL $pit
}

panelinfoboardrevcheck() {
	mntbootscript
	pit="/media/bootscript/panelinfo.txt"

	test -f $pit ||
		return "$(false)"

	is_wallsly &&
		BREV="VS-SH2000-$(chk_board)-Rev-$(chk_rev)"
	is_brazen &&
		BREV="VS-HD1000-$(chk_board)-Rev-$(chk_rev)"

	if ! grep -q "$BREV" "$pit"; then
		mntbootscriptrw
		sed --in-place '/_BOARD_REV/d' $pit
		mntbootscriptro
	fi
	grep -q _BOARD_REV $pit
}

panelinfoboardmodelupdate() {
	pit="/media/bootscript/panelinfo.txt"
	mntbootscriptrw
	addboardmodelfromdevtree
	mntbootscriptro
}

panelinfoboardrevupdate() {
	pit="/media/bootscript/panelinfo.txt"
	mntbootscriptrw
	addboardrevfromdevtree
	mntbootscriptro
}

chargerinit() {
	is_brazen &&
		i2cset -y 1 0x2f 0 44
	true
}

succeed_or bootscrcheck bootscrupdate
succeed_or ubootcheck ubootupdate
succeed_or mmcbootbitscheck mmcbootbitsset
succeed_or fusecheck fuseset

chargerinit

test "${FACTORYFIRSTBOOT}" = "true" && {
	info "Initial factory board setup complete -- halting!"
	sync
	halt -f
}

succeed_or serialnumcheck serialnumwarn
succeed_or panelinfoboardmodelcheck panelinfoboardmodelupdate
succeed_or panelinfoboardrevcheck panelinfoboardrevupdate

info "board re-setup complete, not first time, continuing normal boot..."

exit 0
