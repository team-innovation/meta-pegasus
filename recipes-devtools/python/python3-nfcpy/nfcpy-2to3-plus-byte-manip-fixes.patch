diff -Nurp a/clf/device.py b/nfc/clf/device.py
--- a/clf/device.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/clf/device.py	2016-05-10 14:24:00.000000000 -0600
@@ -129,7 +129,7 @@ class Device(object):
         raise NotImplementedError("%s.%s() must be implemented"%(cname,fname))
         
     def __str__(self):
-        n = filter(bool,(self.vendor_name,self.product_name,self.chipset_name))
+        n = list(filter(bool,(self.vendor_name,self.product_name,self.chipset_name)))
         return ' '.join(n) + " at " + self.path
         
     @property
diff -Nurp a/clf/__init__.py b/nfc/clf/__init__.py
--- a/clf/__init__.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/clf/__init__.py	2016-05-10 14:24:00.000000000 -0600
@@ -788,7 +788,7 @@ class ContactlessFrontend(object):
             self.target = None # forget captured target
             self.device.mute() # deactivate the rf field
             
-            for i in xrange(max(1, options.get('iterations', 1))):
+            for i in range(max(1, options.get('iterations', 1))):
                 started = time.time()
                 for target in targets:
                     log.debug("sense {0}".format(target))
diff -Nurp a/clf/pn533.py b/nfc/clf/pn533.py
--- a/clf/pn533.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/clf/pn533.py	2016-05-10 14:24:00.000000000 -0600
@@ -179,7 +179,7 @@ class Device(pn53x.Device):
         try:
             self.chipset.read_register(0xA000) # check access
             for addr in range(0xA000, 0xA100, 64):
-                data = self.chipset.read_register(*range(addr, addr+64))
+                data = self.chipset.read_register(*list(range(addr, addr+64)))
                 self.eeprom.extend(data)
         except Chipset.Error:
             self.log.debug("no eeprom attached")
diff -Nurp a/clf/pn53x.py b/nfc/clf/pn53x.py
--- a/clf/pn53x.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/clf/pn53x.py	2016-05-10 14:24:00.000000000 -0600
@@ -107,7 +107,7 @@ class Chipset(object):
         0x632E: "CIU_RFT3",
         0x632F: "CIU_RFT4",
     }
-    REGBYNAME = {v: k for k, v in REG.iteritems()}
+    REGBYNAME = {v: k for k, v in REG.items()}
 
     class Error(Exception):
         def __init__(self, errno, strerr):
@@ -684,7 +684,7 @@ class Device(device.Device):
         except AssertionError as error:
             raise ValueError(str(error))
 
-        nfcf_params = bytearray(range(18))
+        nfcf_params = bytearray(list(range(18)))
         nfca_params = target.sens_res + target.sdd_res[1:4] + target.sel_res
         self.log.debug("nfca_params %s", hexlify(nfca_params))
 
@@ -775,7 +775,7 @@ class Device(device.Device):
             ("CIU_Command",   0b00000000), # Idle command
             ("CIU_FIFOLevel", 0b10000000), # clear fifo
         ]
-        regs.extend(zip(25*["CIU_FIFOData"], nfca_params+nfcf_params+"\0"))
+        regs.extend(list(zip(25*["CIU_FIFOData"], nfca_params+nfcf_params+"\0")))
         regs.append(("CIU_Command", 0b00000001)) # Configure command
         self.chipset.write_register(*regs)
         regs = [
@@ -946,7 +946,7 @@ class Device(device.Device):
             ("CIU_DivIRq",    0b01111111), # clear interrupt request bits
         ]
         if data is not None:
-            regs.extend(zip(len(data)*["CIU_FIFOData"], data))
+            regs.extend(list(zip(len(data)*["CIU_FIFOData"], data)))
             regs.append(("CIU_BitFraming", 0b10000000)) # StartSend (b7=1)
         self.chipset.write_register(*regs)
         
@@ -996,7 +996,7 @@ class Device(device.Device):
         for page in pages:
             base = (0x6331, 0x6301, 0x6311, 0x6321)[page]
             regs = set(self.chipset.REG)
-            regs = sorted(regs.intersection(range(base, base+16)))
+            regs = sorted(regs.intersection(list(range(base, base+16))))
             vals = self.chipset.read_register(*regs)
             regs = [self.chipset.REG[r] for r in regs]
             for r, v in zip(regs, vals):
diff -Nurp a/clf/rcs380.py b/nfc/clf/rcs380.py
--- a/clf/rcs380.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/clf/rcs380.py	2016-05-10 14:24:00.000000000 -0600
@@ -46,6 +46,7 @@ listen_dep  yes      Only passive commun
 """
 
 import logging
+from functools import reduce
 log = logging.getLogger(__name__)
 
 import os
@@ -108,7 +109,7 @@ class CommunicationError:
                0x00000800: "TRANSMIT_TIMEOUT_ERROR",
                0x80000000: "RECEIVE_LENGTH_ERROR"
                }
-    str2err = dict([(v, k) for k, v in err2str.iteritems()])
+    str2err = dict([(v, k) for k, v in err2str.items()])
     
     def __init__(self, status_bytes):
         self.errno = struct.unpack('<L', str(status_bytes))[0]
@@ -226,7 +227,7 @@ class Chipset(object):
                 "check_sof", "add_eof", "check_eof", "rfu", "deaf_time",
                 "continuous_receive_mode", "min_len_for_crm",
                 "type_1_tag_rrdd", "rfca", "guard_time")
-        for key, value in kwargs.iteritems():
+        for key, value in kwargs.items():
             data.extend(bytearray([KEYS.index(key), int(value)]))
         if len(data) > 0:
             data = self.send_command(0x02, data)
@@ -261,7 +262,7 @@ class Chipset(object):
         data = bytearray() if data is None else bytearray(data)
         KEYS = ("send_timeout_time_unit", "rf_off_error",
                 "continuous_receive_mode")
-        for key, value in kwargs.iteritems():
+        for key, value in kwargs.items():
             data.extend(bytearray([KEYS.index(key), int(value)]))
         data = self.send_command(0x42, bytearray(data))
         if data and data[0] != 0:
@@ -390,7 +391,7 @@ class Device(device.Device):
                 if len(uid) > 4: uid = "\x88" + uid
                 if len(uid) > 8: uid = uid[0:4] + "\x88" + uid[4:]
                 self.chipset.in_set_protocol(add_crc=1, check_crc=1)
-                for i, sel_cmd in zip(range(0,len(uid),4),"\x93\x95\x97"):
+                for i, sel_cmd in zip(list(range(0,len(uid),4)),"\x93\x95\x97"):
                     sel_req = sel_cmd + "\x70" + uid[i:i+4]
                     sel_req.append(reduce(operator.xor, sel_req[2:6])) # BCC
                     log.debug("send SEL_REQ " + hexlify(sel_req))
diff -Nurp a/clf/transport.py b/nfc/clf/transport.py
--- a/clf/transport.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/clf/transport.py	2016-05-10 14:24:00.000000000 -0600
@@ -179,10 +179,10 @@ class USB(object):
                 log.debug("path matches {0!r}".format(regex.pattern))
                 if regex is usb_vid_pid:
                     match = [int(s.strip(':'), 16) for s in m.groups() if s]
-                    match = dict(zip(['vid', 'pid'], match))
+                    match = dict(list(zip(['vid', 'pid'], match)))
                 if regex is usb_bus_dev:
                     match = [int(s.strip(':'), 10) for s in m.groups() if s]
-                    match = dict(zip(['bus', 'adr'], match))
+                    match = dict(list(zip(['bus', 'adr'], match)))
                 if regex is usb_or_none:
                     match = dict()
                 break
@@ -230,7 +230,7 @@ class USB(object):
             raise IOError(errno.ENODEV, os.strerror(errno.ENODEV))
         
         try:
-            first_setting = dev.iterSettings().next()
+            first_setting = next(dev.iterSettings())
         except StopIteration:
             log.error("no usb configuration settings, please replug device")
             raise IOError(errno.ENODEV, os.strerror(errno.ENODEV))
diff -Nurp a/clf/udp.py b/nfc/clf/udp.py
--- a/clf/udp.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/clf/udp.py	2016-05-10 14:24:00.000000000 -0600
@@ -43,6 +43,7 @@ listen_dep  yes
 
 """
 import logging
+from functools import reduce
 log = logging.getLogger(__name__)
 
 import os
@@ -114,7 +115,7 @@ class Device(nfc.clf.device.Device):
                 uid = target.sel_req
                 if len(uid) > 4: uid = "\x88" + uid
                 if len(uid) > 8: uid = uid[0:4] + "\x88" + uid[4:]
-                for i, sel_cmd in zip(range(0,len(uid),4),"\x93\x95\x97"):
+                for i, sel_cmd in zip(list(range(0,len(uid),4)),"\x93\x95\x97"):
                     sel_req = sel_cmd + "\x70" + uid[i:i+4]
                     sel_req.append(reduce(operator.xor, sel_req[2:6])) # BCC
                     log.debug("send SEL_REQ " + hexlify(sel_req))
diff -Nurp a/dep.py b/nfc/dep.py
--- a/dep.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/dep.py	2016-05-10 14:24:00.000000000 -0600
@@ -45,7 +45,7 @@ class DataExchangeProtocol(object):
         
         def __str__(self):
             s = "sent/rcvd {0}/{1}".format(self.sent_count, self.rcvd_count)
-            for name in sorted(set(self.sent.keys() + self.rcvd.keys())):
+            for name in sorted(set(list(self.sent.keys()) + list(self.rcvd.keys()))):
                 s += " {name} {sent}/{rcvd}".format(
                     name=name, sent=self.sent[name], rcvd=self.rcvd[name])
             return s
diff -Nurp a/__init__.py b/nfc/__init__.py
--- a/__init__.py	2016-04-29 05:07:18.000000000 -0600
+++ b/nfc/__init__.py	2016-05-27 09:41:33.819889292 -0600
@@ -25,4 +25,4 @@ import logging
 logging.getLogger(__name__).addHandler(logging.NullHandler())
 logging.getLogger(__name__).setLevel(logging.INFO)
 
-from clf import ContactlessFrontend
+# from .clf import ContactlessFrontend
diff -Nurp a/llcp/__init__.py b/nfc/llcp/__init__.py
--- a/llcp/__init__.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/llcp/__init__.py	2016-05-10 14:24:00.000000000 -0600
@@ -27,8 +27,8 @@ the connection-less and connection-mode
 import logging
 log = logging.getLogger(__name__)
 
-from socket import Socket
-from llc import LOGICAL_DATA_LINK, DATA_LINK_CONNECTION
-from err import *
-from opt import *
+from .socket import Socket
+from .llc import LOGICAL_DATA_LINK, DATA_LINK_CONNECTION
+from .err import *
+from .opt import *
 
diff -Nurp a/llcp/llc.py b/nfc/llcp/llc.py
--- a/llcp/llc.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/llcp/llc.py	2016-05-10 14:24:00.000000000 -0600
@@ -40,7 +40,7 @@ from . import err
 from . import opt
 from . import sec
 
-RAW_ACCESS_POINT, LOGICAL_DATA_LINK, DATA_LINK_CONNECTION = range(3)
+RAW_ACCESS_POINT, LOGICAL_DATA_LINK, DATA_LINK_CONNECTION = list(range(3))
 
 wks_map = {
     "urn:nfc:sn:sdp" : 1,
@@ -143,7 +143,7 @@ class ServiceDiscovery(object):
     def __init__(self, llc):
         self.llc = llc
         self.snl = dict()
-        self.tids = range(256)
+        self.tids = list(range(256))
         self.resp = threading.Condition(self.llc.lock)
         self.sent = dict()
         self.sdreq = collections.deque()
@@ -250,7 +250,7 @@ class LogicalLinkController(object):
         
         def __str__(self):
             s = "sent/rcvd {0}/{1}".format(self.sent_count, self.rcvd_count)
-            for name in set(self.sent.keys() + self.rcvd.keys()):
+            for name in set(list(self.sent.keys()) + list(self.rcvd.keys())):
                 s += " {name} {sent}/{rcvd}".format(
                     name=name, sent=self.sent[name], rcvd=self.rcvd[name])
             return s
@@ -290,7 +290,7 @@ class LogicalLinkController(object):
         
         send_pax = pdu.ParameterExchange()
         send_pax.version = (1, 3)
-        send_pax.wks = 1+sum([1<<sap for sap in self.snl.values() if sap<15])
+        send_pax.wks = 1+sum([1<<sap for sap in list(self.snl.values()) if sap<15])
         if self.cfg['recv-miu'] != 128:
             send_pax.miu = self.cfg['recv-miu']
         if self.cfg['send-lto'] != 100:
@@ -687,9 +687,9 @@ class LogicalLinkController(object):
             raise err.Error(errno.EINVAL)
         if addr_or_name is None:
             self._bind_by_none(socket)
-        elif type(addr_or_name) is types.IntType:
+        elif type(addr_or_name) is int:
             self._bind_by_addr(socket, addr_or_name)
-        elif type(addr_or_name) is types.StringType:
+        elif type(addr_or_name) is bytes:
             self._bind_by_name(socket, addr_or_name)
         else: raise err.Error(errno.EFAULT)
 
@@ -748,7 +748,7 @@ class LogicalLinkController(object):
             raise err.Error(errno.ENOTSOCK)
         if not isinstance(socket, tco.DataLinkConnection):
             raise err.Error(errno.EOPNOTSUPP)
-        if not type(backlog) == types.IntType:
+        if not type(backlog) == int:
             raise TypeError("backlog must be integer")
         if backlog < 0:
             raise ValueError("backlog mmust not be negative")
@@ -791,7 +791,7 @@ class LogicalLinkController(object):
             # FIXME: set socket send miu when activated
             socket.send_miu = self.cfg['send-miu']
             return socket.send(message, flags)
-        if not type(message) == types.StringType:
+        if not type(message) == bytes:
             raise TypeError("sendto() argument *message* must be a string")
         if isinstance(socket, tco.LogicalDataLink):
             if dest is None:
diff -Nurp a/llcp/pdu.py b/nfc/llcp/pdu.py
--- a/llcp/pdu.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/llcp/pdu.py	2016-05-10 14:24:00.000000000 -0600
@@ -30,7 +30,7 @@ class DecodeError(Error): pass
 class EncodeError(Error): pass
 
 class Parameter:
-    VERSION, MIUX, WKS, LTO, RW, SN, OPT, SDREQ, SDRES, ECPK, RN = range(1, 12)
+    VERSION, MIUX, WKS, LTO, RW, SN, OPT, SDREQ, SDRES, ECPK, RN = list(range(1, 12))
     
     @staticmethod
     def decode(data, offset, size):
@@ -435,7 +435,7 @@ class AggregatedFrameIterator(object):
         self._aggregate = aggregate
         self._current = 0
 
-    def next(self):
+    def __next__(self):
         if self._current == len(self._aggregate):
             raise StopIteration
         self._current += 1
diff -Nurp a/llcp/sec.py b/nfc/llcp/sec.py
--- a/llcp/sec.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/llcp/sec.py	2016-05-10 14:24:00.000000000 -0600
@@ -300,7 +300,7 @@ class OpenSSLWrapper:
             # int EC_KEY_set_public_key_affine_coordinates(EC_KEY *key,
             #     BIGNUM *x, BIGNUM *y);
             r = OpenSSL.crypto.EC_KEY_set_public_key_affine_coordinates(
-                self, *map(OpenSSL.BIGNUM.bin2bn, (pubkey_x, pubkey_y)))
+                self, *list(map(OpenSSL.BIGNUM.bin2bn, (pubkey_x, pubkey_y))))
             if r != 1:
                 raise AssertionError("EC_KEY_set_public_key_affine_coordinates")
 
diff -Nurp a/llcp/tco.py b/nfc/llcp/tco.py
--- a/llcp/tco.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/llcp/tco.py	2016-05-10 14:24:00.000000000 -0600
@@ -434,10 +434,10 @@ class DataLinkConnection(TransmissionCon
                 if self.state.CONNECT:
                     raise err.Error(errno.EALREADY)
                 raise err.Error(errno.EPIPE)
-            if type(dest) is types.StringType:
+            if type(dest) is bytes:
                 send_pdu = pdu.Connect(1, self.addr, self.recv_miu,
                                        self.recv_win, dest)
-            elif type(dest) is types.IntType:
+            elif type(dest) is int:
                 send_pdu = pdu.Connect(dest, self.addr, self.recv_miu,
                                        self.recv_win)
             else:
diff -Nurp a/ndef/bt_record.py b/nfc/ndef/bt_record.py
--- a/ndef/bt_record.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/ndef/bt_record.py	2016-05-10 14:24:00.000000000 -0600
@@ -28,8 +28,8 @@ log = logging.getLogger(__name__)
 import io
 import struct
 from uuid import UUID
-from record import Record
-from error import *
+from .record import Record
+from .error import *
 
 class BluetoothConfigRecord(Record):
     def __init__(self, record=None):
@@ -46,7 +46,7 @@ class BluetoothConfigRecord(Record):
     def data(self):
         f = io.BytesIO()
         f.write(str(bytearray(reversed(self._bdaddr))))
-        for key, value in self.eir.iteritems():
+        for key, value in self.eir.items():
             f.write(chr(1 + len(value)) + chr(key) + str(value))
         oob_length = 2 + f.tell()
         f.seek(0,0)
@@ -219,7 +219,7 @@ class BluetoothConfigRecord(Record):
             try: service_class = service_class_uuid_map[service_class_uuid]
             except KeyError: service_class = service_class_uuid
             lines.append(("service class", service_class))
-        for key, value in self.eir.items():
+        for key, value in list(self.eir.items()):
             if key not in (3, 5, 7, 8, 9, 13, 14, 15):
                 lines.append(("EIR 0x%02x" % key, repr(value)))
         
diff -Nurp a/ndef/handover.py b/nfc/ndef/handover.py
--- a/ndef/handover.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/ndef/handover.py	2016-05-10 14:24:00.000000000 -0600
@@ -27,11 +27,11 @@ log = logging.getLogger(__name__)
 
 import io
 import struct
-from record import Record, RecordList
-from message import Message
-from error import *
-from bt_record import BluetoothConfigRecord
-from wifi_record import WifiConfigRecord
+from .record import Record, RecordList
+from .message import Message
+from .error import *
+from .bt_record import BluetoothConfigRecord
+from .wifi_record import WifiConfigRecord
 
 def parse_carrier_structure(ac_record, records):
     carrier_record = records.get(ac_record.carrier_data_reference)
@@ -104,7 +104,7 @@ class HandoverRequestMessage(object):
 
         if version is not None:
             major, minor = [int(c) for c in version.split('.')]
-            if major != 1 or minor not in range(16):
+            if major != 1 or minor not in list(range(16)):
                 raise ValueError("version not in range 1.0 to 1.15")
             self._version = Version(chr(major << 4 | minor))
 
@@ -346,7 +346,7 @@ class HandoverSelectMessage(object):
                 if carrier: self.carriers.append(carrier)
         elif version is not None:
             major, minor = [int(c) for c in version.split('.')]
-            if major != 1 or minor not in range(16):
+            if major != 1 or minor not in list(range(16)):
                 raise ValueError("version not in range 1.0 to 1.15")
             self._version = Version(chr(major << 4 | minor))
         else:
diff -Nurp a/ndef/message.py b/nfc/ndef/message.py
--- a/ndef/message.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/ndef/message.py	2016-05-27 16:29:16.558980246 -0600
@@ -52,6 +52,8 @@ class Message(object):
                 self._read(args[0])
             elif isinstance(args[0], (str, bytearray)):
                 self._read(io.BytesIO(args[0]))
+            elif isinstance(args[0], (str, bytes)):
+                self._read(io.BytesIO(args[0]))
             elif isinstance(args[0], nfc.ndef.Record):
                 self.append(args[0])
             elif isinstance(args[0], (list, tuple)):
diff -Nurp a/ndef/record.py b/nfc/ndef/record.py
--- a/ndef/record.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/ndef/record.py	2016-05-31 09:16:32.427102431 -0600
@@ -33,7 +33,7 @@ import io
 import re
 
 import nfc.ndef
-from error import LengthError, FormatError
+from .error import LengthError, FormatError
 
 type_name_prefix = (
     '', 'urn:nfc:wkt:', '', '', 'urn:nfc:ext:', 'unknown', 'unchanged')
@@ -140,7 +140,7 @@ class Record(object):
             raise FormatError( s.format(tnf) )
             
         self._message_begin, self._message_end = mbf, mef
-        self._type = bytearray(type_name_prefix[tnf] + record_type)
+        self._type = bytearray(bytes(type_name_prefix[tnf], 'utf-8') + record_type)
         self._name = bytearray(record_name)
         self._data = bytearray(record_data)
         log.debug("parsed {0}".format(repr(self)))
@@ -152,7 +152,8 @@ class Record(object):
         record_type = self.type
         record_name = self.name
         record_data = self.data
-        
+        header_flags = 0
+ 
         if record_type == '':
             header_flags = 0; record_name = ''; record_data = ''
         elif record_type.startswith("urn:nfc:wkt:"):
@@ -188,9 +189,9 @@ class Record(object):
         if name_length > 0:
             f.write(struct.pack(">B", name_length))
 
-        f.write(record_type)
-        f.write(record_name)
-        f.write(record_data)
+        f.write(record_type.encode('utf-8'))
+        f.write(record_name.encode('utf-8'))
+        f.write(record_data.encode('utf-8'))
 
     @property
     def type(self):
@@ -208,7 +209,7 @@ class Record(object):
             value.startswith("urn:nfc:ext:") or
             re.match(r'[a-zA-Z0-9-]+/[a-zA-Z0-9-+.]+', value) or
             re.match(r'[a-zA-Z][a-zA-Z0-9+-.]*://', value)):
-            self._type = bytearray(value)
+            self._type = bytearray(value.encode('utf-8'))
         else:
             log.error("'{0}' is not an acceptable record type".format(value))
             raise ValueError("invalid record type")
@@ -222,7 +223,7 @@ class Record(object):
 
     @name.setter
     def name(self, value):
-        self._name = bytearray(str(value))
+        self._name = bytearray(value.encode('utf-8'))
 
     @property
     def data(self):
@@ -233,7 +234,7 @@ class Record(object):
 
     @data.setter
     def data(self, value):
-        self._data = bytearray(str(value))
+        self._data = bytearray(value.encode('utf-8'))
 
     def __iter__(self):
         from itertools import islice
@@ -247,9 +248,9 @@ class Record(object):
 
     def __repr__(self):
         return "nfc.ndef.Record('{0}', '{1}', '{2}')".format(
-            self.type.encode('string_escape'),
-            self.name.encode('string_escape'),
-            self.data.encode('string_escape'))
+            self.type.encode('unicode_escape'),
+            self.name.encode('unicode_escape'),
+            self.data.encode('unicode_escape'))
 
     def pretty(self, indent=0):
         """Returns a string with a formatted representation that might
diff -Nurp a/ndef/smart_poster.py b/nfc/ndef/smart_poster.py
--- a/ndef/smart_poster.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/ndef/smart_poster.py	2016-05-27 15:28:11.495116441 -0600
@@ -25,10 +25,10 @@ log = logging.getLogger(__name__)
 
 import io
 import struct
-from record import Record
-from message import Message
-from uri_record import UriRecord
-from text_record import TextRecord
+from .record import Record
+from .message import Message
+from .uri_record import UriRecord
+from .text_record import TextRecord
 
 actions = ('default', "exec", "save", "edit")
 
@@ -76,9 +76,9 @@ class SmartPosterRecord(Record):
     def data(self):
         # encode smart poster payload as ndef message
         message = Message(UriRecord(self._uri))
-        for lang, text in self.title.iteritems():
+        for lang, text in self.title.items():
             message.append(TextRecord(text=text, language=lang))
-        for image_type, image_data in self.icons.iteritems():
+        for image_type, image_data in self.icons.items():
             message.append(Record("image/"+image_type, data=image_data))
         if self._action >= 0:
             message.append(Record("urn:nfc:wkt:act", data=chr(self._action)))
@@ -204,11 +204,11 @@ class SmartPosterRecord(Record):
 
     def pretty(self, indent=0):
         lines = list()
-        lines.append(("resource", self.uri))
+        lines.append(("resource", self.uri.decode('utf-8')))
         if self.name:
             lines.append(("identifier", repr(self.name)))
         if self.resource_type:
-            lines.append(("resource type", self.resource_type))
+            lines.append(("resource type", self.resource_type.decode('utf-8')))
         if self.resource_size:
             lines.append(("resource size", str(self.resource_size)))
         for lang in sorted(self.title):
diff -Nurp a/ndef/text_record.py b/nfc/ndef/text_record.py
--- a/ndef/text_record.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/ndef/text_record.py	2016-05-27 15:16:21.263142834 -0600
@@ -25,7 +25,7 @@
 import logging
 log = logging.getLogger(__name__)
 
-from record import Record
+from .record import Record
 
 class TextRecord(Record):
     """Wraps an NDEF Text record and provides access to the
@@ -94,7 +94,7 @@ class TextRecord(Record):
 
     @text.setter
     def text(self, value):
-        self._text = unicode(value)
+        self._text = str(value)
 
     @property
     def language(self):
@@ -130,7 +130,7 @@ class TextRecord(Record):
         if self.name:
             lines.append(("identifier", repr(self.name)))
         lines.append(("text", self.text))
-        lines.append(("language", self.language))
+        lines.append(("language", self.language.decode('utf-8')))
         lines.append(("encoding", self.encoding))
         
         indent = indent * ' '
diff -Nurp a/ndef/uri_record.py b/nfc/ndef/uri_record.py
--- a/ndef/uri_record.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/ndef/uri_record.py	2016-05-27 15:21:50.407130603 -0600
@@ -25,7 +25,7 @@
 import logging
 log = logging.getLogger(__name__)
 
-from record import Record
+from .record import Record
 
 class UriRecord(Record):
     """Wraps an NDEF URI record and provides access to the :attr:`uri`
@@ -99,7 +99,7 @@ class UriRecord(Record):
         lines = list()
         if self.name:
             lines.append(("identifier", repr(self.name)))
-        lines.append(("resource", self.uri))
+        lines.append(("resource", self.uri.decode('utf-8')))
         
         indent = indent * ' '
         lwidth = max([len(line[0]) for line in lines])
diff -Nurp a/ndef/wifi_record.py b/nfc/ndef/wifi_record.py
--- a/ndef/wifi_record.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/ndef/wifi_record.py	2016-05-10 14:24:00.000000000 -0600
@@ -28,8 +28,8 @@ log = logging.getLogger(__name__)
 
 import io
 import struct
-from record import Record
-from error import DecodeError, EncodeError
+from .record import Record
+from .error import DecodeError, EncodeError
 
 VERSION1     = "\x10\x4A"
 CREDENTIAL   = "\x10\x0e"
@@ -64,10 +64,10 @@ crypt_type_names = {
     }
 
 auth_type_keys = \
-    dict([(v,k) for k,v in auth_type_names.iteritems()])
+    dict([(v,k) for k,v in auth_type_names.items()])
 
 crypt_type_keys = \
-    dict([(v,k) for k,v in crypt_type_names.iteritems()])
+    dict([(v,k) for k,v in crypt_type_names.items()])
     
 class WifiConfigRecord(Record):
     def __init__(self, record=None):
@@ -136,7 +136,7 @@ class WifiConfigRecord(Record):
     @version.setter
     def version(self, value):
         try:
-            major, minor = map(int, value.split('.'))
+            major, minor = list(map(int, value.split('.')))
         except:
             raise TypeError("not a 'major.minor' version string")
         if major < 2 or major > 15:
@@ -315,7 +315,7 @@ class WifiPasswordRecord(Record):
     @version.setter
     def version(self, value):
         try:
-            major, minor = map(int, value.split('.'))
+            major, minor = list(map(int, value.split('.')))
         except:
             raise TypeError("not a 'major.minor' version string")
         if major < 2 or major > 15:
diff -Nurp a/snep/client.py b/nfc/snep/client.py
--- a/snep/client.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/snep/client.py	2016-05-10 14:24:00.000000000 -0600
@@ -38,7 +38,7 @@ def send_request(socket, snep_request, s
     if socket.recv() != "\x10\x80\x00\x00\x00\x00":
         return False
 
-    for offset in xrange(send_miu, len(snep_request), send_miu):
+    for offset in range(send_miu, len(snep_request), send_miu):
         fragment = snep_request[offset:offset+send_miu]
         if not socket.send(fragment):
             return False
diff -Nurp a/snep/server.py b/nfc/snep/server.py
--- a/snep/server.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/snep/server.py	2016-05-10 14:24:00.000000000 -0600
@@ -114,7 +114,7 @@ class SnepServer(Thread):
                 else:
                     socket.send(snep_response[0:send_miu])
                     if socket.recv() == "\x10\x00\x00\x00\x00\x00":
-                        parts = range(send_miu, len(snep_response), send_miu)
+                        parts = list(range(send_miu, len(snep_response), send_miu))
                         for offset in parts:
                             fragment = snep_response[offset:offset+send_miu]
                             socket.send(fragment)
diff -Nurp a/tag/pyDes.py b/nfc/tag/pyDes.py
--- a/tag/pyDes.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/tag/pyDes.py	2016-05-10 14:24:00.000000000 -0600
@@ -229,7 +229,7 @@ class _baseDes(object):
 		# Only accept byte strings or ascii unicode values, otherwise
 		# there is no way to correctly decode the data into bytes.
 		if _pythonMajorVersion < 3:
-			if isinstance(data, unicode):
+			if isinstance(data, str):
 				raise ValueError("pyDes can only work with bytes, not Unicode strings.")
 		else:
 			if isinstance(data, str):
@@ -453,7 +453,7 @@ class des(_baseDes):
 
 	def __permutate(self, table, block):
 		"""Permutate this block with the specified table"""
-		return list(map(lambda x: block[x], table))
+		return list([block[x] for x in table])
 	
 	# Transform the secret key, so that it is ready for data processing
 	# Create the 16 subkeys, K[1] - K[16]
diff -Nurp a/tag/tt1.py b/nfc/tag/tt1.py
--- a/tag/tt1.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/tag/tt1.py	2016-05-10 14:24:00.000000000 -0600
@@ -37,7 +37,7 @@ from nfc.tag import Tag, TagCommandError
 import nfc.clf
 
 CHECKSUM_ERROR, RESPONSE_ERROR, WRITE_ERROR, \
-    BLOCK_ERROR, SECTOR_ERROR = range(1, 6)
+    BLOCK_ERROR, SECTOR_ERROR = list(range(1, 6))
 
 class Type1TagCommandError(TagCommandError):
     """Type 1 Tag specific exceptions. Sets 
@@ -67,7 +67,7 @@ def read_tlv(memory, offset, skip_bytes)
     if tlv_l == 0xFF:
         tlv_l, offset = (unpack(">H", memory[offset:offset+2])[0], offset+2)
     tlv_v = bytearray(tlv_l)
-    for i in xrange(tlv_l):
+    for i in range(tlv_l):
         while (offset + i) in skip_bytes:
             offset += 1
         tlv_v[i] = memory[offset+i]
@@ -169,10 +169,10 @@ class Type1Tag(Tag):
                     pass
                 elif tlv_t == 0x01:
                     lock_bytes = get_lock_byte_range(tlv_v)
-                    skip_bytes.update(range(*lock_bytes.indices(0x800)))
+                    skip_bytes.update(list(range(*lock_bytes.indices(0x800))))
                 elif tlv_t == 0x02:
                     rsvd_bytes = get_rsvd_byte_range(tlv_v)
-                    skip_bytes.update(range(*rsvd_bytes.indices(0x800)))
+                    skip_bytes.update(list(range(*rsvd_bytes.indices(0x800))))
                 elif tlv_t == 0x03:
                     ndef = tlv_v; break
                 elif tlv_t == 0xFE or tlv_t is None:
@@ -205,7 +205,7 @@ class Type1Tag(Tag):
             # ndef data into the memory image, but jump over skip
             # bytes.
             offset += 2 if len(data) < 255 else 4
-            for i in xrange(len(data)):
+            for i in range(len(data)):
                 while offset + i in skip_bytes: offset += 1
                 tag_memory[offset+i] = data[i]
             # Write a terminator tlv if space permits. We may have to
@@ -281,7 +281,7 @@ class Type1Tag(Tag):
 
         lines.append("HR0={0:02X}h, HR1={1:02X}h".format(*hrom))
         lines.append("  0: {0} ({1})".format(oprint(data[0:8]), txt[0]))
-        for i in xrange(8, 104, 8):
+        for i in range(8, 104, 8):
             lines.append(lprint("{0:3}: {1} |{2}|", data[i:i+8], i//8))
         lines.append(" 13: {0} ({1})".format(oprint(data[104:112]), txt[1]))
         lines.append(" 14: {0} ({1})".format(oprint(data[112:120]), txt[2]))
@@ -301,7 +301,7 @@ class Type1Tag(Tag):
             if same_data > 0:
                 lines.append(lprint(data_line_fmt, this_data, page))
             
-        for i in xrange(16, stop if stop is not None else 256):
+        for i in range(16, stop if stop is not None else 256):
             try:
                 this_data = self.read_block(i)
                 if stop is None:
@@ -465,7 +465,7 @@ class Type1TagMemoryReader(object):
     def __setitem__(self, key, value):
         self.__getitem__(key)
         if isinstance(key, slice):
-            if len(value) != len(xrange(*key.indices(0x100000))):
+            if len(value) != len(range(*key.indices(0x100000))):
                 msg = "{cls} requires item assignment of identical length"
                 raise ValueError(msg.format(cls=self.__class__.__name__))
         self._data_in_cache[key] = value
@@ -497,13 +497,13 @@ class Type1TagMemoryReader(object):
         try:
             hr0 = self._header_rom[0]
             if hr0 >> 4 == 1 and hr0 & 0x0F != 1:
-                for i in xrange(0, stop, 8):
+                for i in range(0, stop, 8):
                     data = self._data_in_cache[i:i+8]
                     if data != self._data_from_tag[i:i+8]:
                         self._tag.write_block(i//8, data)
                         self._data_from_tag[i:i+8] = data
             else:
-                for i in xrange(0, stop):
+                for i in range(0, stop):
                     data = self._data_in_cache[i]
                     if data != self._data_from_tag[i]:
                         self._tag.write_byte(i, data)
diff -Nurp a/tag/tt2_nxp.py b/nfc/tag/tt2_nxp.py
--- a/tag/tt2_nxp.py	2016-04-29 05:06:29.000000000 -0600
+++ b/nfc/tag/tt2_nxp.py	2016-05-10 14:24:00.000000000 -0600
@@ -66,8 +66,8 @@ class MifareUltralightC(tt2.Type2Tag):
     def dump(self):
         lines = super(MifareUltralightC, self)._dump(stop=40)
         
-        footer = dict(zip(range(40, 44), (
-            "LOCK2-LOCK3", "CTR0-CTR1", "AUTH0", "AUTH1")))
+        footer = dict(list(zip(list(range(40, 44)), (
+            "LOCK2-LOCK3", "CTR0-CTR1", "AUTH0", "AUTH1"))))
         
         for i in sorted(footer.keys()):
             try:
@@ -196,7 +196,7 @@ class MifareUltralightC(tt2.Type2Tag):
         return super(MifareUltralightC, self).authenticate(password)
         
     def _authenticate(self, password):
-        from pyDes import triple_des, CBC
+        from .pyDes import triple_des, CBC
 
         # The first 16 password character bytes are taken as key
         # unless the password is empty. If it's empty we use the
@@ -253,7 +253,7 @@ class NTAG203(tt2.Type2Tag):
     def dump(self):
         lines = super(NTAG203, self)._dump(40)
 
-        footer = dict(zip(range(40, 42), ("LOCK2-LOCK3", "CNTR0-CNTR1")))
+        footer = dict(list(zip(list(range(40, 42)), ("LOCK2-LOCK3", "CNTR0-CNTR1"))))
         
         for i in sorted(footer.keys()):
             try:
@@ -485,9 +485,9 @@ class NTAG210(NTAG21x):
         self._cfgpage = 16
         
     def dump(self):
-        footer = dict(zip(range(16, 20),
+        footer = dict(list(zip(list(range(16, 20)),
                           ("MIRROR_BYTE, RFU, MIRROR_PAGE, AUTH0",
-                           "ACCESS", "PWD0-PWD3", "PACK0-PACK1")))
+                           "ACCESS", "PWD0-PWD3", "PACK0-PACK1"))))
         return super(NTAG210, self)._dump(16, footer)
 
 class NTAG212(NTAG21x):
@@ -503,7 +503,7 @@ class NTAG212(NTAG21x):
     def dump(self):
         text = ("LOCK2-LOCK4", "MIRROR_BYTE, RFU, MIRROR_PAGE, AUTH0",
                 "ACCESS", "PWD0-PWD3", "PACK0-PACK1")
-        footer = dict(zip(range(36, 36+len(text)), text))
+        footer = dict(list(zip(list(range(36, 36+len(text))), text)))
         return super(NTAG212, self)._dump(36, footer)
 
 class NTAG213(NTAG21x):
@@ -520,7 +520,7 @@ class NTAG213(NTAG21x):
     def dump(self):
         text = ("LOCK2-LOCK4", "MIRROR, RFU, MIRROR_PAGE, AUTH0",
                 "ACCESS", "PWD0-PWD3", "PACK0-PACK1")
-        footer = dict(zip(range(40, 40+len(text)), text))
+        footer = dict(list(zip(list(range(40, 40+len(text))), text)))
         return super(NTAG213, self)._dump(40, footer)
 
 class NTAG215(NTAG21x):
@@ -537,7 +537,7 @@ class NTAG215(NTAG21x):
     def dump(self):
         text = ("LOCK2-LOCK4", "MIRROR, RFU, MIRROR_PAGE, AUTH0",
                 "ACCESS", "PWD0-PWD3", "PACK0-PACK1")
-        footer = dict(zip(range(130, 130+len(text)), text))
+        footer = dict(list(zip(list(range(130, 130+len(text))), text)))
         return super(NTAG215, self)._dump(130, footer)
 
 class NTAG216(NTAG21x):
@@ -554,7 +554,7 @@ class NTAG216(NTAG21x):
     def dump(self):
         text = ("LOCK2-LOCK4", "MIRROR, RFU, MIRROR_PAGE, AUTH0",
                 "ACCESS", "PWD0-PWD3", "PACK0-PACK1")
-        footer = dict(zip(range(226, 226+len(text)), text))
+        footer = dict(list(zip(list(range(226, 226+len(text))), text)))
         return super(NTAG216, self)._dump(226, footer)
 
 class MifareUltralightEV1(NTAG21x):
@@ -575,14 +575,14 @@ class MifareUltralightEV1(NTAG21x):
     def _dump_ul11(self):
         text = ("MOD, RFU, RFU, AUTH0", "ACCESS, VCTID, RFU, RFU",
                 "PWD0, PWD1, PWD2, PWD3", "PACK0, PACK1, RFU, RFU")
-        footer = dict(zip(range(16, 16+len(text)), text))
+        footer = dict(list(zip(list(range(16, 16+len(text))), text)))
         return super(MifareUltralightEV1, self)._dump(16, footer)
 
     def _dump_ul21(self):
         text = ("LOCK2, LOCK3, LOCK4, RFU",
                 "MOD, RFU, RFU, AUTH0", "ACCESS, VCTID, RFU, RFU",
                 "PWD0, PWD1, PWD2, PWD3", "PACK0, PACK1, RFU, RFU")
-        footer = dict(zip(range(36, 36+len(text)), text))
+        footer = dict(list(zip(list(range(36, 36+len(text))), text)))
         return super(MifareUltralightEV1, self)._dump(36, footer)
 
 class MF0UL11(MifareUltralightEV1):
diff -Nurp a/tag/tt2.py b/nfc/tag/tt2.py
--- a/tag/tt2.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/tag/tt2.py	2016-05-10 14:24:00.000000000 -0600
@@ -46,7 +46,7 @@ def pagedump(page, octets, info=None):
     return "{0} {1} {2}".format(page, hexdump(octets, sep=" "), info)
 
 TIMEOUT_ERROR, INVALID_SECTOR_ERROR, \
-    INVALID_PAGE_ERROR, INVALID_RESPONSE_ERROR = range(4)
+    INVALID_PAGE_ERROR, INVALID_RESPONSE_ERROR = list(range(4))
 
 class Type2TagCommandError(TagCommandError):
     """Type 2 Tag specific exceptions. Sets 
@@ -75,7 +75,7 @@ def read_tlv(memory, offset, skip_bytes)
     if tlv_l == 0xFF:
         tlv_l, offset = (unpack(">H", memory[offset:offset+2])[0], offset+2)
     tlv_v = bytearray(tlv_l)
-    for i in xrange(tlv_l):
+    for i in range(tlv_l):
         while (offset + i) in skip_bytes:
             offset += 1
         tlv_v[i] = memory[offset+i]
@@ -176,11 +176,11 @@ class Type2Tag(Tag):
                 elif tlv_t == 0x01:
                     try: lock_bytes = get_lock_byte_range(tlv_v)
                     except IndexError: return None
-                    skip_bytes.update(range(*lock_bytes.indices(0x100000)))
+                    skip_bytes.update(list(range(*lock_bytes.indices(0x100000))))
                 elif tlv_t == 0x02:
                     try: rsvd_bytes = get_rsvd_byte_range(tlv_v)
                     except IndexError: return None
-                    skip_bytes.update(range(*rsvd_bytes.indices(0x100000)))
+                    skip_bytes.update(list(range(*rsvd_bytes.indices(0x100000))))
                 elif tlv_t == 0x03:
                     ndef = tlv_v; break
                 elif tlv_t == 0xFE:
@@ -225,7 +225,7 @@ class Type2Tag(Tag):
             # ndef data into the memory image, but jump over skip
             # bytes. If space permits, write a terminator tlv.
             offset += 2 if len(data) < 255 else 4
-            for i in xrange(len(data)):
+            for i in range(len(data)):
                 while offset + i in skip_bytes:
                     offset += 1
                 tag_memory[offset+i] = data[i]
@@ -287,7 +287,7 @@ class Type2Tag(Tag):
             if same_data > 0:
                 lines.append(pagedump(page, this_data))
             
-        for i in xrange(4, stop if stop is not None else 0x40000):
+        for i in range(4, stop if stop is not None else 0x40000):
             try:
                 self.sector_select(i>>8)
                 this_data = self.read(i)[0:4]
@@ -354,7 +354,7 @@ class Type2Tag(Tag):
             if wipe is not None:
                 memory_size = memory[14] * 8 + 16
                 skip_bytes = self.ndef._skip_bytes
-                for offset in xrange(offset + 3, memory_size):
+                for offset in range(offset + 3, memory_size):
                     if offset not in skip_bytes:
                         memory[offset] = wipe & 0xFF
             memory.synchronize()
@@ -619,7 +619,7 @@ class Type2TagMemoryReader(object):
     def __setitem__(self, key, value):
         self.__getitem__(key)
         if isinstance(key, slice):
-            if len(value) != len(xrange(*key.indices(0x100000))):
+            if len(value) != len(range(*key.indices(0x100000))):
                 msg = "{cls} requires item assignment of identical length"
                 raise ValueError(msg.format(cls=self.__class__.__name__))
         self._data_in_cache[key] = value
@@ -632,7 +632,7 @@ class Type2TagMemoryReader(object):
     def _read_from_tag(self, stop):
         start = len(self)
         try:
-            for i in xrange((start>>4)<<4, stop, 16):
+            for i in range((start>>4)<<4, stop, 16):
                 self._tag.sector_select(i>>10)
                 self._data_from_tag[i:i+16] = self._tag.read(i>>2)
                 self._data_in_cache[i:i+16] = self._data_from_tag[i:i+16]
@@ -641,7 +641,7 @@ class Type2TagMemoryReader(object):
 
     def _write_to_tag(self, stop):
         try:
-            for i in xrange(0, stop, 4):
+            for i in range(0, stop, 4):
                 data = self._data_in_cache[i:i+4]
                 if data != self._data_from_tag[i:i+4]:
                     self._tag.sector_select(i>>10)
diff -Nurp a/tag/tt3.py b/nfc/tag/tt3.py
--- a/tag/tt3.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/tag/tt3.py	2016-05-10 14:24:00.000000000 -0600
@@ -34,7 +34,7 @@ else: # for Debian Wheezy (and thus Rasp
 import nfc.tag
 import nfc.clf
 
-RSP_LENGTH_ERROR, RSP_CODE_ERROR, TAG_IDM_ERROR, DATA_SIZE_ERROR = range(1, 5)
+RSP_LENGTH_ERROR, RSP_CODE_ERROR, TAG_IDM_ERROR, DATA_SIZE_ERROR = list(range(1, 5))
         
 class Type3TagCommandError(nfc.tag.TagCommandError):
     errno_str = {
@@ -200,7 +200,7 @@ class Type3Tag(nfc.tag.Tag):
             
             for i in range(1, last_block_number, attributes['nbr']):
                 last_block = min(i + attributes['nbr'], last_block_number)
-                block_list = range(i, last_block)
+                block_list = list(range(i, last_block))
                 try: data += self.tag.read_from_ndef_service(*block_list)
                 except Type3TagCommandError: return None
 
@@ -226,7 +226,7 @@ class Type3Tag(nfc.tag.Tag):
                 last_block = min(i + attributes['nbw'], last_block_number)
                 block_data = data[(i-1)*16:(last_block-1)*16]
                 self._tag.write_to_ndef_service(
-                    block_data, *range(i, last_block))
+                    block_data, *list(range(i, last_block)))
 
             attributes['writef'] = 0x00
             self._write_attribute_data(attributes)
@@ -295,7 +295,7 @@ class Type3Tag(nfc.tag.Tag):
         lines = list()
         last_data = None; same_data = 0
 
-        for i in xrange(0x10000):
+        for i in range(0x10000):
             try: this_data = self.read_without_encryption([sc], [BlockCode(i)])
             except Type3TagCommandError: break
             
@@ -366,7 +366,7 @@ class Type3Tag(nfc.tag.Tag):
         # To get the number of blocks that can be read in one command
         # we just try to read with an increasing number of blocks.
         for i in range(nmaxb + 1):
-            try: self.read_from_ndef_service(*range(0, i+1))
+            try: self.read_from_ndef_service(*list(range(0, i+1)))
             except Type3TagCommandError: break
         else: i = i + 1
         nbr = i
@@ -377,7 +377,7 @@ class Type3Tag(nfc.tag.Tag):
         data = bytearray()
         for i in range(nbr):
             data += self.read_from_ndef_service(i)
-            try: self.write_to_ndef_service(data, *range(0, i+1))
+            try: self.write_to_ndef_service(data, *list(range(0, i+1)))
             except Type3TagCommandError: break
         else: i = i + 1
         nbw = i
@@ -395,7 +395,7 @@ class Type3Tag(nfc.tag.Tag):
         # 8-bit integer provided. This could take a while.
         if wipe is not None:
             data = bytearray(chr(wipe) * 16)
-            for block in xrange(1, nmaxb + 1):
+            for block in range(1, nmaxb + 1):
                 self.write_to_ndef_service(data, block)
 
         return True
@@ -746,7 +746,7 @@ class Type3TagEmulation(nfc.tag.TagEmula
         service_list = cmd_data.pop(0) * [[None, None]]
         for i in range(len(service_list)):
             service_code = cmd_data[1] << 8 | cmd_data[0]
-            if not service_code in self.services.keys():
+            if not service_code in list(self.services.keys()):
                 return bytearray([0xFF, 0xA1])
             service_list[i] = [service_code, 0]
             del cmd_data[0:2]
@@ -793,7 +793,7 @@ class Type3TagEmulation(nfc.tag.TagEmula
         service_list = cmd_data.pop(0) * [[None, None]]
         for i in range(len(service_list)):
             service_code = cmd_data[1] << 8 | cmd_data[0]
-            if not service_code in self.services.keys():
+            if not service_code in list(self.services.keys()):
                 return bytearray([255, 0xA1])
             service_list[i] = [service_code, 0]
             del cmd_data[0:2]
diff -Nurp a/tag/tt3_sony.py b/nfc/tag/tt3_sony.py
--- a/tag/tt3_sony.py	2016-04-22 04:36:25.000000000 -0600
+++ b/nfc/tag/tt3_sony.py	2016-05-10 14:24:00.000000000 -0600
@@ -25,7 +25,7 @@ log = logging.getLogger(__name__)
 
 import sys, os
 from binascii import hexlify
-from pyDes import triple_des, CBC
+from .pyDes import triple_des, CBC
 if sys.hexversion >= 0x020704F0:
     from struct import pack, unpack
 else: # for Debian Wheezy (and thus Raspbian)
@@ -38,15 +38,15 @@ from . import tt3
 def activate(clf, target):
     # http://www.sony.net/Products/felica/business/tech-support/list.html
     ic_code = target.sensf_res[10]
-    if ic_code in FelicaLite.IC_CODE_MAP.keys():
+    if ic_code in list(FelicaLite.IC_CODE_MAP.keys()):
         return FelicaLite(clf, target)
-    if ic_code in FelicaLiteS.IC_CODE_MAP.keys():
+    if ic_code in list(FelicaLiteS.IC_CODE_MAP.keys()):
         return FelicaLiteS(clf, target)
-    if ic_code in FelicaStandard.IC_CODE_MAP.keys():
+    if ic_code in list(FelicaStandard.IC_CODE_MAP.keys()):
         return FelicaStandard(clf, target)
-    if ic_code in FelicaMobile.IC_CODE_MAP.keys():
+    if ic_code in list(FelicaMobile.IC_CODE_MAP.keys()):
         return FelicaMobile(clf, target)
-    if ic_code in FelicaPlug.IC_CODE_MAP.keys():
+    if ic_code in list(FelicaPlug.IC_CODE_MAP.keys()):
         return FelicaPlug(clf, target)
     return None
 
@@ -192,7 +192,7 @@ class FelicaStandard(tt3.Type3Tag):
             # We've already processed the first are/service entry so
             # index starts from 1. The first non-existing index will
             # give us None and thus terminate the loop.
-            for i in xrange(1, 0x10000):
+            for i in range(1, 0x10000):
                 depth = len(area_stack)
                 area_or_service = self.search_service_code(i)
                 if area_or_service is None:
@@ -456,7 +456,7 @@ class FelicaLite(tt3.Type3Tag):
                 "IDM[8], PMM[8]", "SERVICE_CODE[2]",
                 "SYSTEM_CODE[2]", "CKV[2]", "CK1[8], CK2[8]",
                 "MEMORY_CONFIG")
-        config = dict(zip(range(0x80, 0x80+len(text)), text))
+        config = dict(list(zip(list(range(0x80, 0x80+len(text))), text)))
         
         for i in sorted(config.keys()):
             data = self.read_without_mac(i)
@@ -774,7 +774,7 @@ class FelicaLiteS(FelicaLite):
         lines = super(FelicaLiteS, self).dump()
         
         text = ("WCNT[3]", "MAC_A[8]", "STATE")
-        config = dict(zip(range(0x90, 0x90+len(text)), text))
+        config = dict(list(zip(list(range(0x90, 0x90+len(text))), text)))
         
         for i in sorted(config.keys()):
             try:
