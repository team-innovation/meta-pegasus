--- a/examples/miniterm.py	2010-01-01 19:47:50.000000000 -0700
+++ b/examples/miniterm.py	2013-08-26 16:37:58.690248886 -0600
@@ -1,14 +1,14 @@
-#!/usr/bin/env python
+#!/usr/bin/env python3
 
 # Very simple serial terminal
-# (C)2002-2009 Chris Liechti <cliechti@gmx.net>
+# (C)2002-2011 Chris Liechti <cliechti@gmx.net>
 
 # Input characters are sent directly (only LF -> CR/LF/CRLF translation is
 # done), received characters are displayed as is (or escaped trough pythons
 # repr, useful for debug purposes)
 
 
-import sys, os, serial, threading
+import sys, os, serial, threading, atexit
 
 EXITCHARCTER = '\x1d'   # GS/CTRL+]
 MENUCHARACTER = '\x14'  # Menu: CTRL+T
@@ -22,6 +22,7 @@
     else:
         return repr(character)
 
+
 # help text, starts with blank line! it's a function so that the current values
 # for the shortcut keys is used and not the value at program start
 def get_help_text():
@@ -31,26 +32,27 @@
 --- %(exit)-8s Exit program
 --- %(menu)-8s Menu escape key, followed by:
 --- Menu keys:
----       %(itself)-8s Send the menu character itself to remote
----       %(exchar)-8s Send the exit character to remote
----       %(info)-8s Show info
----       %(upload)-8s Upload file (prompt will be shown)
+---    %(itself)-7s Send the menu character itself to remote
+---    %(exchar)-7s Send the exit character itself to remote
+---    %(info)-7s Show info
+---    %(upload)-7s Upload file (prompt will be shown)
 --- Toggles:
----       %(rts)s  RTS          %(echo)s  local echo
----       %(dtr)s  DTR          %(break)s  BREAK
----       %(lfm)s  line feed    %(repr)s  Cycle repr mode
+---    %(rts)-7s RTS          %(echo)-7s local echo
+---    %(dtr)-7s DTR          %(break)-7s BREAK
+---    %(lfm)-7s line feed    %(repr)-7s Cycle repr mode
 ---
 --- Port settings (%(menu)s followed by the following):
---- 7 8           set data bits
---- n e o s m     change parity (None, Even, Odd, Space, Mark)
---- 1 2 3         set stop bits (1, 2, 1.5)
---- b             change baud rate
---- x X           disable/enable software flow control
---- r R           disable/enable hardware flow control
+---    p          change port
+---    7 8        set data bits
+---    n e o s m  change parity (None, Even, Odd, Space, Mark)
+---    1 2 3      set stop bits (1, 2, 1.5)
+---    b          change baud rate
+---    x X        disable/enable software flow control
+---    r R        disable/enable hardware flow control
 """ % {
-    'version': getattr(serial, 'VERSION', 'unkown'),
-    'exit': key_description(EXITCHARCTER),
-    'menu': key_description(MENUCHARACTER),
+    'version': getattr(serial, 'VERSION', 'unknown version'),
+    'exit': key_description(EXITCHARCTER[0]),
+    'menu': key_description(MENUCHARACTER[0]),
     'rts': key_description('\x12'),
     'repr': key_description('\x01'),
     'dtr': key_description('\x04'),
@@ -59,8 +61,8 @@
     'echo': key_description('\x05'),
     'info': key_description('\x09'),
     'upload': key_description('\x15'),
-    'itself': key_description(MENUCHARACTER),
-    'exchar': key_description(EXITCHARCTER),
+    'itself': key_description(MENUCHARACTER[0]),
+    'exchar': key_description(EXITCHARCTER[0]),
 }
 
 # first choose a platform dependant way to read single characters from the console
@@ -68,7 +70,7 @@
 
 if os.name == 'nt':
     import msvcrt
-    class Console:
+    class Console(object):
         def __init__(self):
             pass
 
@@ -79,7 +81,7 @@
             pass    # Do nothing for 'nt'
 
         def getkey(self):
-            while 1:
+            while True:
                 z = msvcrt.getch()
                 if z == '\0' or z == '\xe0':    # functions keys
                     msvcrt.getch()
@@ -92,7 +94,7 @@
 
 elif os.name == 'posix':
     import termios, sys, os
-    class Console:
+    class Console(object):
         def __init__(self):
             self.fd = sys.stdin.fileno()
 
@@ -117,21 +119,21 @@
         console.cleanup()
 
     console.setup()
-    sys.exitfunc = cleanup_console      #terminal modes have to be restored on exit...
+    atexit.register(cleanup_console)      # terminal modes have to be restored on exit...
 
 else:
-    raise "Sorry no implementation for your platform (%s) available." % sys.platform
+    raise NotImplementedError("Sorry no implementation for your platform (%s) available." % sys.platform)
 
 
 CONVERT_CRLF = 2
 CONVERT_CR   = 1
 CONVERT_LF   = 0
-NEWLINE_CONVERISON_MAP = ('\n', '\r', '\r\n')
+NEWLINE_CONVERISON_MAP = (b'\n', b'\r', b'\r\n')
 LF_MODES = ('LF', 'CR', 'CR/LF')
 
 REPR_MODES = ('raw', 'some control', 'all control', 'hex')
 
-class Miniterm:
+class Miniterm(object):
     def __init__(self, port, baudrate, parity, rtscts, xonxoff, echo=False, convert_outgoing=CONVERT_CRLF, repr_mode=0):
         try:
             self.serial = serial.serial_for_url(port, baudrate, parity=parity, rtscts=rtscts, xonxoff=xonxoff, timeout=1)
@@ -147,15 +149,26 @@
         self.rts_state = True
         self.break_state = False
 
-    def start(self):
-        self.alive = True
+    def _start_reader(self):
+        """Start reader thread"""
+        self._reader_alive = True
         # start serial->console thread
         self.receiver_thread = threading.Thread(target=self.reader)
-        self.receiver_thread.setDaemon(1)
+        self.receiver_thread.setDaemon(True)
         self.receiver_thread.start()
+
+    def _stop_reader(self):
+        """Stop reader thread only, wait for clean exit of thread"""
+        self._reader_alive = False
+        self.receiver_thread.join()
+
+
+    def start(self):
+        self.alive = True
+        self._start_reader()
         # enter console->serial loop
         self.transmitter_thread = threading.Thread(target=self.writer)
-        self.transmitter_thread.setDaemon(1)
+        self.transmitter_thread.setDaemon(True)
         self.transmitter_thread.start()
 
     def stop(self):
@@ -168,53 +181,55 @@
 
     def dump_port_settings(self):
         sys.stderr.write("\n--- Settings: %s  %s,%s,%s,%s\n" % (
-            self.serial.portstr,
-            self.serial.baudrate,
-            self.serial.bytesize,
-            self.serial.parity,
-            self.serial.stopbits,
-        ))
-        sys.stderr.write('--- RTS %s\n' % (self.rts_state and 'active' or 'inactive'))
-        sys.stderr.write('--- DTR %s\n' % (self.dtr_state and 'active' or 'inactive'))
-        sys.stderr.write('--- BREAK %s\n' % (self.break_state and 'active' or 'inactive'))
-        sys.stderr.write('--- software flow control %s\n' % (self.serial.xonxoff and 'active' or 'inactive'))
-        sys.stderr.write('--- hardware flow control %s\n' % (self.serial.rtscts and 'active' or 'inactive'))
-        sys.stderr.write('--- data escaping: %s\n' % (REPR_MODES[self.repr_mode],))
-        sys.stderr.write('--- linefeed: %s\n' % (LF_MODES[self.convert_outgoing],))
+                self.serial.portstr,
+                self.serial.baudrate,
+                self.serial.bytesize,
+                self.serial.parity,
+                self.serial.stopbits))
+        sys.stderr.write('--- RTS: %-8s  DTR: %-8s  BREAK: %-8s\n' % (
+                (self.rts_state and 'active' or 'inactive'),
+                (self.dtr_state and 'active' or 'inactive'),
+                (self.break_state and 'active' or 'inactive')))
         try:
-            sys.stderr.write('--- CTS: %s  DSR: %s  RI: %s  CD: %s\n' % (
-                (self.serial.getCTS() and 'active' or 'inactive'),
-                (self.serial.getDSR() and 'active' or 'inactive'),
-                (self.serial.getRI() and 'active' or 'inactive'),
-                (self.serial.getCD() and 'active' or 'inactive'),
-                ))
+            sys.stderr.write('--- CTS: %-8s  DSR: %-8s  RI: %-8s  CD: %-8s\n' % (
+                    (self.serial.getCTS() and 'active' or 'inactive'),
+                    (self.serial.getDSR() and 'active' or 'inactive'),
+                    (self.serial.getRI() and 'active' or 'inactive'),
+                    (self.serial.getCD() and 'active' or 'inactive')))
         except serial.SerialException:
             # on RFC 2217 ports it can happen to no modem state notification was
             # yet received. ignore this error.
             pass
+        sys.stderr.write('--- software flow control: %s\n' % (self.serial.xonxoff and 'active' or 'inactive'))
+        sys.stderr.write('--- hardware flow control: %s\n' % (self.serial.rtscts and 'active' or 'inactive'))
+        sys.stderr.write('--- data escaping: %s  linefeed: %s\n' % (
+                REPR_MODES[self.repr_mode],
+                LF_MODES[self.convert_outgoing]))
 
     def reader(self):
         """loop and copy serial->console"""
         try:
-            while self.alive:
+            while self.alive and self._reader_alive:
                 data = self.serial.read(1)
 
                 if self.repr_mode == 0:
                     # direct output, just have to care about newline setting
-                    if data == '\r' and self.convert_outgoing == CONVERT_CR:
+                    if data == b'\r' and self.convert_outgoing == CONVERT_CR:
                         sys.stdout.write('\n')
                     else:
-                        sys.stdout.write(data)
+                        if data != b'':
+#                             sys.stdout.write(ascii(data))
+                             sys.stdout.write(str(data,'ascii'))
                 elif self.repr_mode == 1:
                     # escape non-printable, let pass newlines
-                    if self.convert_outgoing == CONVERT_CRLF and data in '\r\n':
-                        if data == '\n':
+                    if self.convert_outgoing == CONVERT_CRLF and str(data,'ascii') in '\r\n':
+                        if data == b'\n':
                             sys.stdout.write('\n')
-                        elif data == '\r':
+                        elif data == b'\r':
                             pass
-                    elif data == '\n' and self.convert_outgoing == CONVERT_LF:
+                    elif data == b'\n' and self.convert_outgoing == CONVERT_LF:
                         sys.stdout.write('\n')
-                    elif data == '\r' and self.convert_outgoing == CONVERT_CR:
+                    elif data == b'\r' and self.convert_outgoing == CONVERT_CR:
                         sys.stdout.write('\n')
                     else:
                         sys.stdout.write(repr(data)[1:-1])
@@ -224,9 +239,9 @@
                 elif self.repr_mode == 3:
                     # escape everything (hexdump)
                     for character in data:
-                        sys.stdout.write("%s " % character.encode('hex'))
+                        sys.stdout.write("%x " % character)
                 sys.stdout.flush()
-        except serial.SerialException, e:
+        except serial.SerialException as e:
             self.alive = False
             # would be nice if the console reader could be interruptted at this
             # point...
@@ -234,15 +249,17 @@
 
 
     def writer(self):
-        """loop and copy console->serial until EXITCHARCTER character is
-           found. when MENUCHARACTER is found, interpret the next key
-           locally.
+        """\
+        Loop and copy console->serial until EXITCHARCTER character is
+        found. When MENUCHARACTER is found, interpret the next key
+        locally.
         """
         menu_active = False
         try:
             while self.alive:
                 try:
-                    c = console.getkey()
+                    cc = console.getkey()
+                    c = str(cc,'ascii')
                 except KeyboardInterrupt:
                     c = '\x03'
                 if menu_active:
@@ -269,7 +286,7 @@
                                     self.serial.flush()
                                     sys.stderr.write('.')   # Progress indicator.
                                 sys.stderr.write('\n--- File %s sent ---\n' % filename)
-                            except IOError, e:
+                            except IOError as e:
                                 sys.stderr.write('--- ERROR opening file %s: %s ---\n' % (filename, e))
                         console.setup()
                     elif c in '\x08hH?':                    # CTRL+H, h, H, ? -> Show help
@@ -306,7 +323,43 @@
                         sys.stderr.write('--- line feed %s ---\n' % (
                             LF_MODES[self.convert_outgoing],
                         ))
-                    #~ elif c in 'pP':                         # P -> change port XXX reader thread would exit
+                    elif c in 'pP':                         # P -> change port
+                        sys.stderr.write('\n--- Enter port name: ')
+                        sys.stderr.flush()
+                        console.cleanup()
+                        try:
+                            port = sys.stdin.readline().strip()
+                        except KeyboardInterrupt:
+                            port = None
+                        console.setup()
+                        if port and port != self.serial.port:
+                            # reader thread needs to be shut down
+                            self._stop_reader()
+                            # save settings
+                            settings = self.serial.getSettingsDict()
+                            try:
+                                try:
+                                    new_serial = serial.serial_for_url(port, do_not_open=True)
+                                except AttributeError:
+                                    # happens when the installed pyserial is older than 2.5. use the
+                                    # Serial class directly then.
+                                    new_serial = serial.Serial()
+                                    new_serial.port = port
+                                # restore settings and open
+                                new_serial.applySettingsDict(settings)
+                                new_serial.open()
+                                new_serial.setRTS(self.rts_state)
+                                new_serial.setDTR(self.dtr_state)
+                                new_serial.setBreak(self.break_state)
+                            except Exception as e:
+                                sys.stderr.write('--- ERROR opening new port: %s ---\n' % (e,))
+                                new_serial.close()
+                            else:
+                                self.serial.close()
+                                self.serial = new_serial
+                                sys.stderr.write('--- Port changed to: %s ---\n' % (self.serial.port,))
+                            # and restart the reader thread
+                            self._start_reader()
                     elif c in 'bB':                         # B -> change baudrate
                         sys.stderr.write('\n--- Baudrate: ')
                         sys.stderr.flush()
@@ -314,7 +367,7 @@
                         backup = self.serial.baudrate
                         try:
                             self.serial.baudrate = int(sys.stdin.readline().strip())
-                        except ValueError, e:
+                        except ValueError as e:
                             sys.stderr.write('--- ERROR setting baudrate: %s ---\n' % (e,))
                             self.serial.baudrate = backup
                         else:
@@ -367,12 +420,12 @@
                 elif c == '\n':
                     self.serial.write(self.newline)         # send newline character(s)
                     if self.echo:
-                        sys.stdout.write(c)                 # local echo is a real newline in any case
+                        sys.stdout.write(str(c,'ascii'))                 # local echo is a real newline in any case
                         sys.stdout.flush()
                 else:
-                    self.serial.write(c)                    # send character
+                    self.serial.write(cc)                    # send character
                     if self.echo:
-                        sys.stdout.write(c)
+                        sys.stdout.write(str(c,'ascii'))
                         sys.stdout.flush()
         except:
             self.alive = False
@@ -388,7 +441,7 @@
 
     parser.add_option("-p", "--port",
         dest = "port",
-        help = "port, a number (default 0) or a device name (deprecated option)",
+        help = "port, a number or a device name. (deprecated option, use parameter instead)",
         default = None
     )
 
@@ -543,7 +596,7 @@
             convert_outgoing=convert_outgoing,
             repr_mode=options.repr_mode,
         )
-    except serial.SerialException, e:
+    except serial.SerialException as e:
         sys.stderr.write("could not open port %r: %s\n" % (port, e))
         sys.exit(1)
 
@@ -574,7 +627,10 @@
         miniterm.rts_state = options.rts_state
 
     miniterm.start()
-    miniterm.join(True)
+    try:
+        miniterm.join(True)
+    except KeyboardInterrupt:
+        pass
     if not options.quiet:
         sys.stderr.write("\n--- exit ---\n")
     miniterm.join()
